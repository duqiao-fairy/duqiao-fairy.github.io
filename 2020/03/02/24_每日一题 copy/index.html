<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="duqiao"><meta name="renderer" content="webkit"><meta name="copyright" content="duqiao"><meta name="keywords" content="Hexo"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>每日一题 · duqiao's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/dq.JPG"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">duqiao</div><div class="profile-signature">自律即自由</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">duqiao's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">每日一题</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2020-03-02</span></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p><a href="https://juejin.im/post/5ac2329b6fb9a028bf057caf" target="_blank" rel="noopener">参考</a></p>
<h3 id="1-写React-Vue项目时为什么要在列表组件中写key-其作用是什么"><a href="#1-写React-Vue项目时为什么要在列表组件中写key-其作用是什么" class="headerlink" title="1. 写React/Vue项目时为什么要在列表组件中写key, 其作用是什么?"></a>1. 写React/Vue项目时为什么要在列表组件中写key, 其作用是什么?</h3><p>key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。</p>
<p>vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中（建议先了解一下diff算法过程）。<br>在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key =&gt; index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</p>
<p>就react而言，key是对于列表组件而言，并且无key或者key不唯一会报错提示</p>
<h3 id="2-‘1’-‘2’-‘3’-map-parseInt-what-amp-why"><a href="#2-‘1’-‘2’-‘3’-map-parseInt-what-amp-why" class="headerlink" title="2. [‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?"></a>2. [‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?</h3><p><strong>答案: [1, NaN, NaN]</strong></p>
<p>  parseInt()传递两个参数: 字符串和基数。<br>  所以实际执行的的代码是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(item, index)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即返回的值分别为:</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1'</span>, <span class="number">0</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2'</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3'</span>, <span class="number">2</span>) <span class="comment">// NaN, 3 不是二进制</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-什么是防抖和节流-有什么区别-如何实现"><a href="#3-什么是防抖和节流-有什么区别-如何实现" class="headerlink" title="3. 什么是防抖和节流? 有什么区别? 如何实现"></a>3. 什么是防抖和节流? 有什么区别? 如何实现</h3><p><strong>1. 防抖</strong></p>
<blockquote>
<p>触发高频时间后n秒函数只会执行一次, 如果n秒内高频事件再次被触发, 则重新计算时间</p>
</blockquote>
<ul>
<li>思路: </li>
</ul>
<blockquote>
<p>每次触发事件时都取消之前的延时调用方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>; <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      clearTimeout(timeout); <span class="comment">// 每当用户输入的时候把前一个 setTimeout clear 掉</span></span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span></span><br><span class="line">        fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'防抖成功'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> inp = <span class="built_in">document</span>.getElementById(<span class="string">'inp'</span>);</span><br><span class="line">  inp.addEventListener(<span class="string">'input'</span>, debounce(sayHi)); <span class="comment">// 防抖</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 节流</strong></p>
<blockquote>
<p>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</p>
</blockquote>
<ul>
<li>思路: </li>
</ul>
<blockquote>
<p>每次触发事件时都判断当前是否有等待执行的延时函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> canRun = <span class="literal">true</span>; <span class="comment">// 通过闭包保存一个标记</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>; <span class="comment">// 在函数开头判断标记是否为true，不为true则return</span></span><br><span class="line">      canRun = <span class="literal">false</span>; <span class="comment">// 立即设置为false</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 将外部传入的函数的执行放在setTimeout中</span></span><br><span class="line">        fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉</span></span><br><span class="line">        canRun = <span class="literal">true</span>;</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target.innerWidth, e.target.innerHeight);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, throttle(sayHi));</span><br></pre></td></tr></table></figure>
<h3 id="4-介绍下-Set、Map、WeakSet-和-WeakMap-的区别？"><a href="#4-介绍下-Set、Map、WeakSet-和-WeakMap-的区别？" class="headerlink" title="4. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？"></a>4. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</h3><p><strong>1. set: 无重复值的数组</strong></p>
<p>Set 结构的实例有以下属性: </p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
<li>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</li>
<li>add(value)：添加某个值，返回 Set 结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<p><strong>2. map: 无重复值的数组</strong></p>
<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<h3 id="5-介绍下深度优先遍历和广度优先遍历，如何实现？"><a href="#5-介绍下深度优先遍历和广度优先遍历，如何实现？" class="headerlink" title="5. 介绍下深度优先遍历和广度优先遍历，如何实现？"></a>5. 介绍下深度优先遍历和广度优先遍历，如何实现？</h3><p><strong>深度优先(DFS): 找到一个节点后, 把它的后背都找出来, 最常用递归法</strong><br><strong>广度优先(BFS): 找到一个节点后, 把他同级的兄弟节点都找出来放在前边, 还在放到后边,最常用while</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB947603bd74ca243975ec7f20b31a1d30?method=download&amp;shareKey=f61cde0dd64ef496645ac3a0324c304e" alt="image"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*深度优先遍历三种方式*/</span></span><br><span class="line"><span class="keyword">let</span> deepTraversal1 = <span class="function">(<span class="params">node, nodeList = []</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    nodeList.push(node)</span><br><span class="line">    <span class="keyword">let</span> children = node.children</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      deepTraversal1(children[i], nodeList)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodeList</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deepTraversal2 = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> nodes = []</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nodes.push(node)</span><br><span class="line">      <span class="keyword">let</span> children = node.children</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">        nodes = nodes.concat(deepTraversal2(children[i]))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="keyword">let</span> deepTraversal3 = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">let</span> nodes = []</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="comment">// 推入当前处理的node</span></span><br><span class="line">    stack.push(node)</span><br><span class="line">    <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = stack.pop()</span><br><span class="line">      <span class="keyword">let</span> children = item.children</span><br><span class="line">      nodes.push(item)</span><br><span class="line">      <span class="comment">// node = [] stack = [parent]</span></span><br><span class="line">      <span class="comment">// node = [parent] stack = [child3,child2,child1]</span></span><br><span class="line">      <span class="comment">// node = [parent, child1] stack = [child3,child2,child1-2,child1-1]</span></span><br><span class="line">      <span class="comment">// node = [parent, child1-1] stack = [child3,child2,child1-2]</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = children.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        stack.push(children[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="keyword">let</span> widthTraversal2 = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> nodes = []</span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    stack.push(node)</span><br><span class="line">    <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = stack.shift()</span><br><span class="line">      <span class="keyword">let</span> children = item.children</span><br><span class="line">      nodes.push(item)</span><br><span class="line">        <span class="comment">// 队列，先进先出</span></span><br><span class="line">        <span class="comment">// nodes = [] stack = [parent]</span></span><br><span class="line">        <span class="comment">// nodes = [parent] stack = [child1,child2,child3]</span></span><br><span class="line">        <span class="comment">// nodes = [parent, child1] stack = [child2,child3,child1-1,child1-2]</span></span><br><span class="line">        <span class="comment">// nodes = [parent,child1,child2]</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">        stack.push(children[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-请分别用深度优先思想和广度优先思想实现一个拷贝函数"><a href="#6-请分别用深度优先思想和广度优先思想实现一个拷贝函数" class="headerlink" title="6. 请分别用深度优先思想和广度优先思想实现一个拷贝函数"></a>6. 请分别用深度优先思想和广度优先思想实现一个拷贝函数</h3><p><strong>DFS: 递归</strong><br><strong>BFS: 队列</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h3 id="7-ES5-ES6-的继承除了写法以外还有什么区别？？"><a href="#7-ES5-ES6-的继承除了写法以外还有什么区别？？" class="headerlink" title="7. ES5/ES6 的继承除了写法以外还有什么区别？？"></a>7. ES5/ES6 的继承除了写法以外还有什么区别？？</h3><h3 id="8-setTimeout、Promise、Async-Await-的区别？"><a href="#8-setTimeout、Promise、Async-Await-的区别？" class="headerlink" title="8. setTimeout、Promise、Async/Await 的区别？"></a>8. setTimeout、Promise、Async/Await 的区别？</h3><p>这三者在事件循环的区别, 事件循环中氛围宏任务队列和微任务队列.<br>其中<strong>settimeout</strong>的回调函数放到宏任务队列里, 等到执行栈清空以后执行;<br><strong>promise.then</strong>里的会放到相应微任务队列里, 等宏任务里面的同步代码执行完再执行;<br><strong>async</strong>函数表示函数里面可能会有异步方法, await后面跟一个表达式, async方法执行时, 遇到await会立即执行表达式, 然后把表达式后面的代码放到微任务队列里, 让出执行栈让同步代码先执行.</p>
<h3 id="9-Async-Await-如何通过同步的方式实现异步"><a href="#9-Async-Await-如何通过同步的方式实现异步" class="headerlink" title="9. Async/Await 如何通过同步的方式实现异步"></a>9. Async/Await 如何通过同步的方式实现异步</h3><h3 id="10-异步笔试题"><a href="#10-异步笔试题" class="headerlink" title="10. 异步笔试题"></a>10. 异步笔试题</h3><blockquote>
<p>请写出下面代码的运行结果</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://yoursite.com">duqiao</a></p><p> <span>Link:  </span><a href="http://yoursite.com/2020/03/02/24_每日一题 copy/">http://yoursite.com/2020/03/02/24_每日一题 copy/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2020/03/02/25_数据结构设计/" title="数据结构设计"><span>< PreviousPost</span><br><span class="prevTitle">数据结构设计</span></a><a class="nextSlogan" href="/2020/03/02/26_hybrid/" title="hybrid"><span>NextPost ></span><br><span class="nextTitle">hybrid</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-写React-Vue项目时为什么要在列表组件中写key-其作用是什么"><span class="toc-number">1.</span> <span class="toc-text">1. 写React/Vue项目时为什么要在列表组件中写key, 其作用是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-‘1’-‘2’-‘3’-map-parseInt-what-amp-why"><span class="toc-number">2.</span> <span class="toc-text">2. [‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-什么是防抖和节流-有什么区别-如何实现"><span class="toc-number">3.</span> <span class="toc-text">3. 什么是防抖和节流? 有什么区别? 如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-介绍下-Set、Map、WeakSet-和-WeakMap-的区别？"><span class="toc-number">4.</span> <span class="toc-text">4. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-介绍下深度优先遍历和广度优先遍历，如何实现？"><span class="toc-number">5.</span> <span class="toc-text">5. 介绍下深度优先遍历和广度优先遍历，如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-请分别用深度优先思想和广度优先思想实现一个拷贝函数"><span class="toc-number">6.</span> <span class="toc-text">6. 请分别用深度优先思想和广度优先思想实现一个拷贝函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-ES5-ES6-的继承除了写法以外还有什么区别？？"><span class="toc-number">7.</span> <span class="toc-text">7. ES5/ES6 的继承除了写法以外还有什么区别？？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-setTimeout、Promise、Async-Await-的区别？"><span class="toc-number">8.</span> <span class="toc-text">8. setTimeout、Promise、Async/Await 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Async-Await-如何通过同步的方式实现异步"><span class="toc-number">9.</span> <span class="toc-text">9. Async/Await 如何通过同步的方式实现异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-异步笔试题"><span class="toc-number">10.</span> <span class="toc-text">10. 异步笔试题</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>