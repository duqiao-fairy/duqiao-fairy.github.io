<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="杜俏"><meta name="renderer" content="webkit"><meta name="copyright" content="杜俏"><meta name="keywords" content="Hexo"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>前端知识_javascript基础 · duqiao's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/dq.JPG"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">duqiao</div><div class="profile-signature">自律即自由</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">duqiao's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">前端知识_javascript基础</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2020-03-02 18:35:22</span></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>整理掘金上的文章 一名【合格】前端工程师的自检清单: <a href="https://juejin.im/post/5cc1da82f265da036023b628" target="_blank" rel="noopener">https://juejin.im/post/5cc1da82f265da036023b628</a> 的答案</p>
<h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><h3 id="1-JavaScript规定了几种语言类型"><a href="#1-JavaScript规定了几种语言类型" class="headerlink" title="1. JavaScript规定了几种语言类型"></a>1. JavaScript规定了几种语言类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两类: 基础类型和引用类型;</span><br><span class="line">基础类型: <span class="built_in">Number</span>, <span class="built_in">String</span>, <span class="built_in">Boolean</span>, Null, Undifined, <span class="built_in">Symbol</span>(ES6新增);</span><br><span class="line">引用类型: <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="2-JavaScript对象的底层数据结构是什么"><a href="#2-JavaScript对象的底层数据结构是什么" class="headerlink" title="2. JavaScript对象的底层数据结构是什么"></a>2. JavaScript对象的底层数据结构是什么</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象数据被存储于堆中(如对象, 数组, 函数等, 它们是通过拷贝和<span class="keyword">new</span>出来的)</span><br><span class="line">引用类型的数据的地址指针是存储于栈中的, 当我们想要访问引用类型的值的时候, 需要先从栈中获得对象的地址指针, 然后, 再通过地址指针找到对堆中所需要的数据</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://zhuanlan.zhihu.com/p/26169639" target="_blank" rel="noopener">从Chrome源码看JS Object的实现</a></p>
<h3 id="3-Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"><a href="#3-Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol" class="headerlink" title="3. Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"></a>3. Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ES6 引入了一种新的原始数据类型 <span class="built_in">Symbol</span>，表示独一无二的值。</span><br><span class="line">symbol类型的 key 不能被 <span class="built_in">Object</span>.keys 和 <span class="keyword">for</span>..of 循环枚举。因此可当作私有变量使用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>(<span class="string">'key'</span>)</span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello'</span></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://github.com/mqyqingfeng/Blog/issues/87" target="_blank" rel="noopener">手动实现Symbol</a></p>
<h3 id="4-JavaScript中的变量在内存中的具体存储形式"><a href="#4-JavaScript中的变量在内存中的具体存储形式" class="headerlink" title="4.JavaScript中的变量在内存中的具体存储形式"></a>4.JavaScript中的变量在内存中的具体存储形式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">栈内存和堆内存</span><br><span class="line">JavaScript中的变量分为基本类型和引用类型</span><br><span class="line">基本类型是保存在栈内存中的简单数据段, 他们数值都有固定的大小, 保存在栈空间, 通过按值访问</span><br><span class="line">引用类型是保存在堆内存中的对象, 值大小不固定, 栈内存中存放该对象的访问地址指向堆内存中的对象, JavaScript不允许直接访问堆内存中的位置, 因此操作对象时, 实际操作对象的引用</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://www.jianshu.com/p/80bb5a01857a" target="_blank" rel="noopener">JavaScript中的变量在内存中的具体存储形式</a></p>
<h3 id="5-基本类型对应的内置对象，以及他们之间的装箱拆箱操作"><a href="#5-基本类型对应的内置对象，以及他们之间的装箱拆箱操作" class="headerlink" title="5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作"></a>5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作</h3><p>String(), Number(), Boolean()</p>
<p>装箱: 就是把基本类型转变为相应的对象, 装箱分为隐式和显示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式装箱: 每当读取一个基本类型的值的时候, 后台会创建一个该基本类型所对应的的独享</span></span><br><span class="line"><span class="comment">// 在这个基本类型上调用方法, 其实是在这个基本类型对象上调用方法</span></span><br><span class="line"><span class="comment">// 这个基本类型的对象是临时的, 它只存在于方法调用那一行代码执行的瞬间, 执行方法后立刻被销毁</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">123</span></span><br><span class="line">num.toFixed(<span class="number">2</span>) <span class="comment">// '123.00'</span></span><br><span class="line"><span class="comment">// 上方代码在后台的真正步骤为</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>)</span><br><span class="line">c.toFixed(<span class="number">2</span>)</span><br><span class="line">c = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 显示装箱: 通过内置对象 Boolean, Object, String等可以对基本类型显示装箱</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123)</span></span><br></pre></td></tr></table></figure>
<p>拆箱: 拆箱与装箱相反, 把对象转变为基本类型的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>]) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 转变演变</span></span><br><span class="line">[<span class="number">1</span>].valueOf() <span class="comment">// [1]</span></span><br><span class="line">[<span class="number">1</span>].toString() <span class="comment">// '1'</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'1'</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="6-理解值类型和引用类型"><a href="#6-理解值类型和引用类型" class="headerlink" title="6.理解值类型和引用类型"></a>6.理解值类型和引用类型</h3><p>JavaScript中的变量分为基本类型和引用类型<br>基本类型: 保存在栈内存中的简单数据段, 它们的值都有固定的大小, 保存在栈空间, 通过按值访问</p>
<p>引用类型: 保存在堆内存中的对象, 值大小不固定, 栈内存中存放的该对象的访问地址指向堆内存中的对象, JavaScript不允许直接访问堆内存中的位置, 因此操作对象时, 实际操作对象的引用</p>
<h3 id="7-null和undefined的区别"><a href="#7-null和undefined的区别" class="headerlink" title="7.null和undefined的区别"></a>7.null和undefined的区别</h3><ol>
<li><p>Number 转换的值不同，Number(null) 输出为 0, Number(undefined) 输出为 NaN</p>
</li>
<li><p>null 表示一个值被定义了，但是这个值是空值</p>
</li>
<li><p>undefined 表示缺少值，即此处应该有值，但是还没有定义</p>
</li>
</ol>
<h3 id="8-至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型"><a href="#8-至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型" class="headerlink" title="8.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型"></a>8.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</h3><ol>
<li><p>typeof —— 返回给定变量的数据类型，可能返回如下字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'undefined'</span>——Undefined</span><br><span class="line"> <span class="string">'boolean'</span>——<span class="built_in">Boolean</span></span><br><span class="line"> <span class="string">'string'</span>——<span class="built_in">String</span></span><br><span class="line"> <span class="string">'number'</span>——<span class="built_in">Number</span></span><br><span class="line"> <span class="string">'symbol'</span>——<span class="built_in">Symbol</span></span><br><span class="line"> <span class="string">'object'</span>——<span class="built_in">Object</span> / Null （Null 为空对象的引用）</span><br><span class="line"> <span class="string">'function'</span>——<span class="built_in">Function</span></span><br><span class="line"> <span class="comment">// 对于一些如 error() date() array()无法判断，都是显示object类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>instanceof 检测 constructor.prototype是否存在于参数object的原型链上, 是则返回true, 不是则返回false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alert([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="comment">// true</span></span><br><span class="line">alert(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name=<span class="string">"22"</span>;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">//true</span></span><br><span class="line">alert(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.name=<span class="string">"22"</span>;&#125; <span class="keyword">instanceof</span> <span class="function"><span class="keyword">function</span>) //<span class="title">false</span></span></span><br><span class="line"><span class="function">// <span class="title">instanceof</span> 只能用来判断两个对象是否属于实例关系，而不能判断一个对象实例具体属于哪种类型。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>constructor —— 返回对象对应的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">alert(&#123;&#125;.constructor === <span class="built_in">Object</span>);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert([].constructor === <span class="built_in">Array</span>);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert(<span class="string">'abcde'</span>.constructor === <span class="built_in">String</span>);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert((<span class="number">1</span>).constructor === <span class="built_in">Number</span>);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert(<span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert(<span class="literal">false</span>.constructor === <span class="built_in">Boolean</span>);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert(<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;&#125;.constructor === <span class="built_in">Function</span>);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Date</span>().constructor === <span class="built_in">Date</span>);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Array</span>().constructor === <span class="built_in">Array</span>);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Error</span>().constructor === <span class="built_in">Error</span>);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert(<span class="built_in">document</span>.constructor === HTMLDocument);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert(<span class="built_in">window</span>.constructor === Window);  =&gt;  <span class="literal">true</span></span><br><span class="line">alert(<span class="built_in">Symbol</span>().constructor);    =&gt;    <span class="literal">undefined</span> </span><br><span class="line"><span class="comment">// null 和 undefined 是无效的对象，没有 constructor，因此无法通过这种方式来判断。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Object.prototype.toString() 默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，是一个字符串，其中 Xxx 就是对象的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>);<span class="comment">//[object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">String</span>);<span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Math</span>);<span class="comment">//[object Math]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>);<span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>);<span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">''</span>) ;   <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">123</span>) ;    <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) ; <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()); <span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Function</span>()) ; <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>()) ; <span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ; <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">RegExp</span>()) ; <span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Error</span>()) ; <span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ; <span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ; <span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="9-可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用"><a href="#9-可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用" class="headerlink" title="9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用"></a>9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用</h3><p>隐式转换一般说的是Boolean的转换<br>在if的语句中, null, “”, undefined, 0, false都会被转化为false<br>一般应用于对接口数据判空时使用</p>
<h3 id="10-出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法"><a href="#10-出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法" class="headerlink" title="10.出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法"></a>10.出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法</h3><p>精度丢失原因，说是 JavaScript 使用了 IEEE 754 规范，二进制储存十进制的小数时不能完整的表示小数</p>
<p>能够表示的最大数字 Number.MAX_VALUE 等于 1.7976931348623157e+308 ,最大安全数字 Number.MAX_SAFE_INTEGER 等于 9007199254740991</p>
<p>避免精度丢失</p>
<p>计算小数时，先乘 100 或 1000，变成整数再运算<br>如果值超出了安全整数，有一个最新提案，BigInt 大整数，它可以表示任意大小的整数，注意只能表示整数，而不受安全整数的限制</p>
<p>More info: <a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener">JavaScript中的变量在内存中的具体存储形式</a></p>
<h2 id="原型和原型链-12-26"><a href="#原型和原型链-12-26" class="headerlink" title="原型和原型链(12.26)"></a>原型和原型链(12.26)</h2><h3 id="1-理解原型设计模式以及JavaScript中的原型规则"><a href="#1-理解原型设计模式以及JavaScript中的原型规则" class="headerlink" title="1. 理解原型设计模式以及JavaScript中的原型规则"></a>1. 理解原型设计模式以及JavaScript中的原型规则</h3><p>prototype 和 <strong> proto</strong><br>prototype: 原型<br><strong>proto</strong>: 原型链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prototype: 是只有函数才有的, 别的对象没有, 每一个函数都有一个原型</span><br><span class="line">如: function Fn () &#123;&#125;</span><br><span class="line">1) 一旦这样声明, 浏览器会创建一个Fn.prototype</span><br><span class="line">   typeof Fn.prototype === &apos;object&apos;</span><br><span class="line">2) 浏览器会给这个原型对象添加一个方法, 叫做constructor, 而且&apos;默认&apos;这个constructor就是函数自己</span><br><span class="line">   Fn.prototype.constructor = Fn</span><br></pre></td></tr></table></figure>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3724c00563aa2b07d19766bbff60e2a8?method=download&amp;shareKey=2dab6578a920bb0a1996de247e5ebbae" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__prototype__: 原型链</span><br><span class="line">1) 只要是对象就有__prototype__, 该对象的__prototype__指向该对象&quot;构造函数的prototype&quot;</span><br><span class="line">如:</span><br><span class="line">    var arr = [];</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    arr.__proto__ === Array.prototype // true</span><br><span class="line">    obj.__proto__ === Object.prototype // true</span><br><span class="line">2) __prototype__的作用是: 可以通过__prototype__找到该对象下的方法, 而且可以一层一层的网上找, 直到顶级.</span><br><span class="line">如下图, arr对象下面没有push这个方法, arr.__proto__下面才有push这个方法, 但是arr.push有值, 标识arr是可以调用push方法的, 因为arr.__proto__里面有push, arr.__proto__下面没有hasOwnProperty这个方法, arr.__proto__.__proto__下面有hasOwnProperty这个方法</span><br><span class="line">arr.hasOwnProperty有值, 表示arr可以调用hasOwnProperty这个方法, 就是通过__proto__的__proto__一次原型链网上找的</span><br><span class="line">顶层链是: Object.prototype</span><br></pre></td></tr></table></figure>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB34c2d667a61c046bde75ac757477e80e?method=download&amp;shareKey=5212ce3b4ac3a243eb9e5bf1e2eff086" alt="image"></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBeacc66ed2c8533fc110a7024e843499d?method=download&amp;shareKey=2adcf144bceae04b92a2775485ab6c66" alt="image"></p>
<h3 id="2-instanceof的底层实现原理，手动实现一个instanceof"><a href="#2-instanceof的底层实现原理，手动实现一个instanceof" class="headerlink" title="2.instanceof的底层实现原理，手动实现一个instanceof"></a>2.instanceof的底层实现原理，手动实现一个instanceof</h3><p>简单说就是判断实例对象的<strong>proto</strong>是不是强等于对象的prototype属性, 如果不是继续往原型链上找, 直到<strong>proto</strong>为null为止.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceOf</span> (<span class="params">obj, object</span>) </span>&#123; <span class="comment">// obj表示实例对象, object 表示对象</span></span><br><span class="line">  <span class="keyword">var</span> O = object.prototype</span><br><span class="line">  obj = obj.__proto__</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (O === obj) &#123; <span class="comment">// 重点; 当o严格等于obj时, 返回true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    obj = obj.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-创建对象的方法以及他们的优缺点"><a href="#3-创建对象的方法以及他们的优缺点" class="headerlink" title="3.创建对象的方法以及他们的优缺点"></a>3.创建对象的方法以及他们的优缺点</h3><p>more info: <a href="https://github.com/mqyqingfeng/Blog/issues/15" target="_blank" rel="noopener">JavaScript深入之创建对象的多种方式以及优缺点</a></p>
<h3 id="4-实现继承的几种方式以及他们的优缺点"><a href="#4-实现继承的几种方式以及他们的优缺点" class="headerlink" title="4.实现继承的几种方式以及他们的优缺点"></a>4.实现继承的几种方式以及他们的优缺点</h3><p>为什么要继承, 就是为了展现更多形态, 更多扩展 </p>
<p>1). 拷贝继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 声明一个函数</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 2. 一个私有属性</span></span><br><span class="line">  <span class="keyword">this</span>.sex = options.sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 在公有属性prototype这里加入一个方法</span></span><br><span class="line">Person.prototype.getSex = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> GoodPerson = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>. options)</span><br><span class="line">  <span class="keyword">this</span>.job = options.job</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-至少说出一种开源项目-如Node-中应用原型继承的案例"><a href="#5-至少说出一种开源项目-如Node-中应用原型继承的案例" class="headerlink" title="5.至少说出一种开源项目(如Node)中应用原型继承的案例"></a>5.至少说出一种开源项目(如Node)中应用原型继承的案例</h3><h3 id="6-可以描述new一个对象的详细过程，手动实现一个new操作符"><a href="#6-可以描述new一个对象的详细过程，手动实现一个new操作符" class="headerlink" title="6.可以描述new一个对象的详细过程，手动实现一个new操作符"></a>6.可以描述new一个对象的详细过程，手动实现一个new操作符</h3><h3 id="7-理解es6-class构造以及继承的底层实现原理"><a href="#7-理解es6-class构造以及继承的底层实现原理" class="headerlink" title="7.理解es6 class构造以及继承的底层实现原理"></a>7.理解es6 class构造以及继承的底层实现原理</h3><h2 id="作用域和闭包-2-6"><a href="#作用域和闭包-2-6" class="headerlink" title="作用域和闭包(2.6)"></a>作用域和闭包(2.6)</h2><h3 id="1-理解词法作用域和动态作用域"><a href="#1-理解词法作用域和动态作用域" class="headerlink" title="1.理解词法作用域和动态作用域"></a>1.理解词法作用域和动态作用域</h3><p>词法作用域也称静态作用域, javascript采用静态作用域</p>
<p>静态作用域: 函数的作用域基于函数创建的位置<br>动态作用域: 函数的作用域基于函数的使用位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span></span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line">bar() <span class="comment">// 输出1, Javascript采用的是词法作用域, 也称为静态作用域.</span></span><br></pre></td></tr></table></figure>
<h3 id="2-理解JavaScript的作用域和作用域链"><a href="#2-理解JavaScript的作用域和作用域链" class="headerlink" title="2.理解JavaScript的作用域和作用域链"></a>2.理解JavaScript的作用域和作用域链</h3><p>作用域(scope): 就是变量访问规则的有效范围.<br>作用域链: 当查找变量的时候, 会先从当前上下文的变量查找, 如果没有找到, 就从父级(词法层面的父级)执行上下文的变量对象查找,<br>一直找到全局上下文的变量对象, 也就是全局对象. 由多个执行上下文的变量对象构成的链, 就是作用域链</p>
<h3 id="3-理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题"><a href="#3-理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题" class="headerlink" title="3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题"></a>3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题</h3><p>执行上下文: 当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。<br>执行上下有三个重要属性(也就是前面 3 题所说的内容):<br>  变量对象<br>  作用域链<br>  this</p>
<p>执行代码:<br>  全局代码<br>  函数<br>  eval</p>
<p>执行上下文栈: 每个函数都会创建执行上下文，执行上下文栈（Execution context stack，ECS）就是 JavaScript 引擎创建出来管理执行上下文的。<br>执行上下文栈是有全局上下文初始化，由于执行代码首先是全局代码。全局上下文永远在执行上下文栈中的最底下，只有等程序关闭才释放。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 ECS 是个数组</span></span><br><span class="line"><span class="comment">// 第一步 初始化， 全局代码的上下文 globalContext</span></span><br><span class="line">ECS = [</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步 执行 foo</span></span><br><span class="line"></span><br><span class="line">ECS = [</span><br><span class="line">  globalContext,</span><br><span class="line">  fooContext</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 第三步 执行 bar</span></span><br><span class="line"></span><br><span class="line">ECS = [</span><br><span class="line">  globalContext,</span><br><span class="line">  fooContext,</span><br><span class="line">  barContext</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四步 bar 执行完成, 释放 barContext</span></span><br><span class="line">ECS = [</span><br><span class="line">  globalContext,</span><br><span class="line">  fooContext</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第五步 foo 执行完成, 释放 fooContext</span></span><br><span class="line">ECS = [</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用"><a href="#5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用" class="headerlink" title="5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用"></a>5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用</h3><p>原理: 闭包就是能够读取其他函数内部变量的函数. 由于在javascript语言中, 只有函数内部的子函数才能读取局部变量,<br>因此可以把闭包简单理解成”定一个在一个函数内部的函数”</p>
<p>所以, 在本质上, 闭包就是将函数内部和函数外部连接起来的一座桥梁.</p>
<p>作用: 闭包可以用在很多地方. 它的最大用处有两个, 一个是前面提到的可以读取函数内部的变量, 拎一个就是让这些变量的<br>值始终保持在内存中.</p>
<p>应用: 1. 匿名函数的自执行函数. 2. 结果缓存. 3. 封装局部变量</p>
<h3 id="6-理解堆栈溢出和内存泄漏的原理，如何防止"><a href="#6-理解堆栈溢出和内存泄漏的原理，如何防止" class="headerlink" title="6.理解堆栈溢出和内存泄漏的原理，如何防止"></a>6.理解堆栈溢出和内存泄漏的原理，如何防止</h3><p>堆栈溢出: 由于过多的函数调用, 导致调用栈无法容纳这些调用的返回地址, 一般在递归中产生.<br>堆栈溢出很可能由无限递归产生, 但也可能仅仅是过多的堆栈层级</p>
<p>内存泄露: </p>
<ol>
<li>闭包</li>
<li>意外的全局变量引起的内存泄露</li>
<li>定时器没有及时的被销毁</li>
<li>没有清理的dom元素的引用</li>
<li>监听事件造成的泄露</li>
</ol>
<p>内存泄露的避免: </p>
<ol>
<li><p>谨慎使用闭包 a、在业务不需要用到的内部函数，可以重构在函数外，实现解除闭包.<br>b、闭包内，局部变量使用后或不再需要，及时的清除掉</p>
</li>
<li><p>减少不必要的全局变量，如果用了，最好在声明周期钩子中或再函数调用之前，及时的清除掉.</p>
</li>
<li>减少生命周期较长的对象，及时对无用的数据进行释放销毁.</li>
<li>避免创建过多的对象，对不用的对象及时的释放.</li>
<li>对注册的事件，再不用的时候，及时的解耦.释放资源.</li>
</ol>
<h3 id="7-如何处理循环的异步操作"><a href="#7-如何处理循环的异步操作" class="headerlink" title="7.如何处理循环的异步操作"></a>7.如何处理循环的异步操作</h3><ol>
<li>将异步操作变同步, 使用async/await</li>
<li>去掉循环, 将循环变成递归</li>
</ol>
<h3 id="8-理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理"><a href="#8-理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理" class="headerlink" title="8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理"></a>8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理</h3><p><a href="https://github.com/mqyqingfeng/Blog/issues/108" target="_blank" rel="noopener">模块加载方案</a></p>
<h2 id="执行机制-2-7"><a href="#执行机制-2-7" class="headerlink" title="执行机制(2.7)"></a>执行机制(2.7)</h2><h3 id="1-为何try里面放return，finally还会执行，理解其内部机制"><a href="#1-为何try里面放return，finally还会执行，理解其内部机制" class="headerlink" title="1.为何try里面放return，finally还会执行，理解其内部机制"></a>1.为何try里面放return，finally还会执行，理解其内部机制</h3><h3 id="2-JavaScript如何实现异步编程，可以详细描述EventLoop机制"><a href="#2-JavaScript如何实现异步编程，可以详细描述EventLoop机制" class="headerlink" title="2.JavaScript如何实现异步编程，可以详细描述EventLoop机制"></a>2.JavaScript如何实现异步编程，可以详细描述EventLoop机制</h3><h3 id="3-宏任务和微任务分别有哪些"><a href="#3-宏任务和微任务分别有哪些" class="headerlink" title="3.宏任务和微任务分别有哪些"></a>3.宏任务和微任务分别有哪些</h3><h3 id="4-可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法"><a href="#4-可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法" class="headerlink" title="4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法"></a>4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法</h3><h3 id="5-使用Promise实现串行"><a href="#5-使用Promise实现串行" class="headerlink" title="5.使用Promise实现串行"></a>5.使用Promise实现串行</h3><h3 id="6-Node与浏览器EventLoop的差异"><a href="#6-Node与浏览器EventLoop的差异" class="headerlink" title="6.Node与浏览器EventLoop的差异"></a>6.Node与浏览器EventLoop的差异</h3><h3 id="7-如何在保证页面运行流畅的情况下处理海量数据"><a href="#7-如何在保证页面运行流畅的情况下处理海量数据" class="headerlink" title="7.如何在保证页面运行流畅的情况下处理海量数据"></a>7.如何在保证页面运行流畅的情况下处理海量数据</h3><h2 id="语法和API-2-8"><a href="#语法和API-2-8" class="headerlink" title="语法和API(2. 8)"></a>语法和API(2. 8)</h2><h3 id="1-理解ECMAScript和JavaScript的关系"><a href="#1-理解ECMAScript和JavaScript的关系" class="headerlink" title="1.理解ECMAScript和JavaScript的关系"></a>1.理解ECMAScript和JavaScript的关系</h3><h3 id="2-熟练运用es5、es6提供的语法规范，"><a href="#2-熟练运用es5、es6提供的语法规范，" class="headerlink" title="2.熟练运用es5、es6提供的语法规范，"></a>2.熟练运用es5、es6提供的语法规范，</h3><h3 id="3-熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）"><a href="#3-熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）" class="headerlink" title="3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）"></a>3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）</h3><h3 id="4-熟练应用map、reduce、filter-等高阶函数解决问题"><a href="#4-熟练应用map、reduce、filter-等高阶函数解决问题" class="headerlink" title="4.熟练应用map、reduce、filter 等高阶函数解决问题"></a>4.熟练应用map、reduce、filter 等高阶函数解决问题</h3><h3 id="5-setInterval需要注意的点，使用settimeout实现setInterval"><a href="#5-setInterval需要注意的点，使用settimeout实现setInterval" class="headerlink" title="5.setInterval需要注意的点，使用settimeout实现setInterval"></a>5.setInterval需要注意的点，使用settimeout实现setInterval</h3><h3 id="6-JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题"><a href="#6-JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题" class="headerlink" title="6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题"></a>6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题</h3><h3 id="7-JavaScript异常处理的方式，统一的异常处理方案"><a href="#7-JavaScript异常处理的方式，统一的异常处理方案" class="headerlink" title="7.JavaScript异常处理的方式，统一的异常处理方案"></a>7.JavaScript异常处理的方式，统一的异常处理方案</h3></article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://duqiao-fairy.github.io">杜俏</a></p><p> <span>Link:  </span><a href="https://duqiao-fairy.github.io/2020/03/02/01_javascript基础/">https://duqiao-fairy.github.io/2020/03/02/01_javascript基础/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2020/03/02/07_前端工程/" title="前端知识_前端工程"><span>< PreviousPost</span><br><span class="prevTitle">前端知识_前端工程</span></a><a class="nextSlogan" href="/2020/03/02/09_js练习题/" title="js练习题"><span>NextPost ></span><br><span class="nextTitle">js练习题</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#变量和类型"><span class="toc-number">1.</span> <span class="toc-text">变量和类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JavaScript规定了几种语言类型"><span class="toc-number">1.1.</span> <span class="toc-text">1. JavaScript规定了几种语言类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JavaScript对象的底层数据结构是什么"><span class="toc-number">1.2.</span> <span class="toc-text">2. JavaScript对象的底层数据结构是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol"><span class="toc-number">1.3.</span> <span class="toc-text">3. Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JavaScript中的变量在内存中的具体存储形式"><span class="toc-number">1.4.</span> <span class="toc-text">4.JavaScript中的变量在内存中的具体存储形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-基本类型对应的内置对象，以及他们之间的装箱拆箱操作"><span class="toc-number">1.5.</span> <span class="toc-text">5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-理解值类型和引用类型"><span class="toc-number">1.6.</span> <span class="toc-text">6.理解值类型和引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-null和undefined的区别"><span class="toc-number">1.7.</span> <span class="toc-text">7.null和undefined的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型"><span class="toc-number">1.8.</span> <span class="toc-text">8.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用"><span class="toc-number">1.9.</span> <span class="toc-text">9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法"><span class="toc-number">1.10.</span> <span class="toc-text">10.出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型和原型链-12-26"><span class="toc-number">2.</span> <span class="toc-text">原型和原型链(12.26)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-理解原型设计模式以及JavaScript中的原型规则"><span class="toc-number">2.1.</span> <span class="toc-text">1. 理解原型设计模式以及JavaScript中的原型规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-instanceof的底层实现原理，手动实现一个instanceof"><span class="toc-number">2.2.</span> <span class="toc-text">2.instanceof的底层实现原理，手动实现一个instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-创建对象的方法以及他们的优缺点"><span class="toc-number">2.3.</span> <span class="toc-text">3.创建对象的方法以及他们的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-实现继承的几种方式以及他们的优缺点"><span class="toc-number">2.4.</span> <span class="toc-text">4.实现继承的几种方式以及他们的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-至少说出一种开源项目-如Node-中应用原型继承的案例"><span class="toc-number">2.5.</span> <span class="toc-text">5.至少说出一种开源项目(如Node)中应用原型继承的案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-可以描述new一个对象的详细过程，手动实现一个new操作符"><span class="toc-number">2.6.</span> <span class="toc-text">6.可以描述new一个对象的详细过程，手动实现一个new操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-理解es6-class构造以及继承的底层实现原理"><span class="toc-number">2.7.</span> <span class="toc-text">7.理解es6 class构造以及继承的底层实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域和闭包-2-6"><span class="toc-number">3.</span> <span class="toc-text">作用域和闭包(2.6)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-理解词法作用域和动态作用域"><span class="toc-number">3.1.</span> <span class="toc-text">1.理解词法作用域和动态作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-理解JavaScript的作用域和作用域链"><span class="toc-number">3.2.</span> <span class="toc-text">2.理解JavaScript的作用域和作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题"><span class="toc-number">3.3.</span> <span class="toc-text">3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-闭包的实现原理和作用，可以列举几个开发中闭包的实际应用"><span class="toc-number">3.4.</span> <span class="toc-text">5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-理解堆栈溢出和内存泄漏的原理，如何防止"><span class="toc-number">3.5.</span> <span class="toc-text">6.理解堆栈溢出和内存泄漏的原理，如何防止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-如何处理循环的异步操作"><span class="toc-number">3.6.</span> <span class="toc-text">7.如何处理循环的异步操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理"><span class="toc-number">3.7.</span> <span class="toc-text">8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行机制-2-7"><span class="toc-number">4.</span> <span class="toc-text">执行机制(2.7)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-为何try里面放return，finally还会执行，理解其内部机制"><span class="toc-number">4.1.</span> <span class="toc-text">1.为何try里面放return，finally还会执行，理解其内部机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JavaScript如何实现异步编程，可以详细描述EventLoop机制"><span class="toc-number">4.2.</span> <span class="toc-text">2.JavaScript如何实现异步编程，可以详细描述EventLoop机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-宏任务和微任务分别有哪些"><span class="toc-number">4.3.</span> <span class="toc-text">3.宏任务和微任务分别有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法"><span class="toc-number">4.4.</span> <span class="toc-text">4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-使用Promise实现串行"><span class="toc-number">4.5.</span> <span class="toc-text">5.使用Promise实现串行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Node与浏览器EventLoop的差异"><span class="toc-number">4.6.</span> <span class="toc-text">6.Node与浏览器EventLoop的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-如何在保证页面运行流畅的情况下处理海量数据"><span class="toc-number">4.7.</span> <span class="toc-text">7.如何在保证页面运行流畅的情况下处理海量数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语法和API-2-8"><span class="toc-number">5.</span> <span class="toc-text">语法和API(2. 8)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-理解ECMAScript和JavaScript的关系"><span class="toc-number">5.1.</span> <span class="toc-text">1.理解ECMAScript和JavaScript的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-熟练运用es5、es6提供的语法规范，"><span class="toc-number">5.2.</span> <span class="toc-text">2.熟练运用es5、es6提供的语法规范，</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）"><span class="toc-number">5.3.</span> <span class="toc-text">3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-熟练应用map、reduce、filter-等高阶函数解决问题"><span class="toc-number">5.4.</span> <span class="toc-text">4.熟练应用map、reduce、filter 等高阶函数解决问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-setInterval需要注意的点，使用settimeout实现setInterval"><span class="toc-number">5.5.</span> <span class="toc-text">5.setInterval需要注意的点，使用settimeout实现setInterval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题"><span class="toc-number">5.6.</span> <span class="toc-text">6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-JavaScript异常处理的方式，统一的异常处理方案"><span class="toc-number">5.7.</span> <span class="toc-text">7.JavaScript异常处理的方式，统一的异常处理方案</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>