---
title: 常见面试题
---

## 转转
### 1、rem布局

rem是css的长度单位, 它是相对于<html>元素的font-size的相对值. 假设html{ font-size: 20px; }, 那么1rem就等于20px.

```javascript
1rem === html的font-size
```
其实rem布局的本质是等比缩放，一般是基于宽度.

### 2. 项目上线系统的原理是什么

我们的上线系统有两套, 一个是def, 一个是faas

## 跟谁学
### 1. 跨域如何解决
jsonp
cors

cors跨域：
1）简单请求
请求方法：get、post、head
请求头：accept、accept-language、content-language、content-type（application/x-www-form-urlencoded、multipart/form-data、text/plain）

简单请求，浏览器直接发出跨域请求，直接在头信息中添加origin字段

2）、非简单请求
先发一个预检请求，来让服务器确认是否支持发送这样的请求
预检请求的request header 会有以下几个头信息：
origin
access-control-allow-method：
access-control-allow-header：额外发送的请求字段


### 2. 实现轮播图组件


### 3. 手写js map函数

```javascript
  Array.prototype.MyMap = function (fn, context) {
    // 能将具有length属性的对象转成数组
    let arr = Array.prototype.slice.call(this)
    let newArr = []
    for(let i = 0; i < arr.length; i ++) {
      newArr.push(fn.call(context, arr[i], i, this))
    }
    return newArr
  }
```

### 4. 深拷贝

**1) 浅拷贝**
1. Object.assign()
2. Array.prototype.cancat()
3. Array.prototype.slice() 

**2) 深拷贝**
1. JSON.parse(JSON.stringify())
原理: 用JSON.stringfy将对象转成JSON字符串, 再用JSON.parse()把字符串解析成对象, 一去一来, 新的对象产生了, 而且对象会开辟新的栈, 实现深拷贝.
注意: 这种方法虽然可以实现数组或对象深拷贝, 但不能处理函数.

2. 手写递归方法
递归方法实现深度克隆原理: 遍历对象, 数组直到里面都是基本数据类型, 然后再去复制, 就是深度拷贝
```javascript
  function deepClone (obj) {
    // 1. 判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝
    // 第一种方法
    // var objClone = Array.inArray(obj) ? [] : {}
    // 第二种方法
    // var objClone = obj instanceof Array ? [] : {}
    // 第三种方法
    var objClone = obj.constructor === Array ? [] : {}

    for(let k in obj) {
      if(typeof obj[k] === 'object') {
        objClone[k] = deepClone(obj[k])
      } else {
        objClone[k] = obj[k]
      }
    }
    return objClone
  }
```


3. 函数库lodash
该函数库也有提供_.cloneDeep用来做Deep Copy

### 5. textarea 设置padding好像有什么问题？这个好像我没怎么遇见


## 小米

### 1. 深克隆(可能会有数组的)
注意点：
1）、实现方案   JSON.parse + JSON.stringify  问题：无法实现对function、RegExp等特殊对象的克隆
2）、会抛弃对象的constructor,所有的构造函数会指向Object
3）、对象有循环引用,会报错

### 2. bind的实现

```javascript
  Function.prototype.myBind = function(oThis) {
    if (typeof this != 'function') {
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable')
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNop = function() {},
    fBound = function() {
      return fToBind.apply(
        this instanceof fBound ? this : oThis,
        aArgs.concat(Array.prototype.slice.call(arguments))
      )
    }

    if (this.prototype) {
      fNop.prototype = this.prototype
    }
    fBound.prototype = new fNop()
    return fBound
  }
```

### 3. ES6的 Generator async await

1) Generator函数是ES6提供的一种异步变成解决方案, 是一个状态机, 封装了多个内部状态.

执行generator函数返回的是一个遍历器对象, 也就是说, 我们可以使用next方法, 来遍历generator函数内部的每一个状态.

既然generator函数内部具有多个状态, 那么总该有一个标识来决定函数在遍历过程中应该在哪里停下来, 所以我们需要yield.

2) async 函数是什么 ? 一句话, 他就是 Generator函数的语法糖

### 4. 简单算法 两个有序子数组，合并成一个数组，如何实现，降低时间复杂度那种

```javascript
  // 方法一: 
  function concatArrs(arr1, arr2) {
    const arr = arr1.concat(arr2)
    return arr.sort((a, b) => {
      return a - b
    })
  }
  console.log(concatArrs([1, 2, 5], [1, 4, 6]))

  // 方法二: 
  function concatArrs2(arr1, arr2) {
    let index1 = 0 // 标记arr1的对比元素的初始索引值
    let index2 = 0 // 标记arr2的对比元素的初始索引值
    let newArr = [] // 作为输出的新数组

    // 当arr1 和 arr2元素均未全部存入arr中, 则从数组第一个元素开始进行比较, 将较小的元素存入newArr中
    while (index1 < arr1.length && index2 < arr2.length) {
      if (arr1[index1] <= arr2[index2]) { // 若arr1元素小于arr2元素, 则将arr1的元素存入newArr中
        newArr.push(arr1.slice(index1)[0]) // 已将元素push到输出数组中, 将数组arr1的index指向移动到下一个
        index1 ++
      } else {
        newArr.push(arr2.slice(index2)[0])
        index2 ++
      }
    }
    // 当不满足上述while条件(index1 < arr1.length && index2 < arr1.length)时, 就直接将剩余数组元素拼接输出数组newArr后面
    return newArr.concat(index1 < arr1.length ? arr1.slice(index1) : arr2.slice(index2))
  }

  console.log(concatArrs2([1, 2, 5], [1, 4, 6]))
```

### 5. es6的class会继承static的属性吗


## 搜狐
### 1. 写一个jsonp，jsonp的返回值是什么？

### 2. BFC

BFC: 块级格式化上下文, 是css布局的一个概念, 它是页面中的一块渲染区域, 有一套渲染规则, 决定了其子元素如何布局, 以及和其他元素之间的关系和作用.

通俗解释: BFC可以简单的理解为某个元素的一个CSS属性, 只不过这个属性不能被开发者显示的修改, 拥有这个属性的元素对内部元素和外部元素会表现出一些特性, 这就是BFC

触发条件或者说哪些元素会生成BFC：
满足下列条件之一就可触发BFC
　　【1】根元素，即HTML元素
　　【2】float的值不为none
　　【3】overflow的值不为visible
　　【4】display的值为inline-block、table-cell、table-caption
　　【5】position的值为absolute或fixed


BFC布局规则：
1.内部的Box会在垂直方向，一个接一个地放置。
2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
4.BFC的区域不会与float box重叠。
5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6.计算BFC的高度时，浮动元素也参与计算

BFC布局规则：
1.内部的Box会在垂直方向，一个接一个地放置。
2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
4.BFC的区域不会与float box重叠。
5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6.计算BFC的高度时，浮动元素也参与计算

BFC有哪些作用：
1. 自适应两栏布局
2. 可以阻止元素被浮动元素覆盖
3. 可以包含浮动元素——清除内部浮动
4. 分属于不同的BFC时可以阻止margin重叠

### 3. Promise实现原理, 动手实现Promise

```javascript
  class MyPromise {
    // 构造器
    constructor (executor) {
      // 初始化state为等待态
      this.state = 'pending'
      // 成功的值
      this.value = undefined
      // 失败的原因
      this.reason = undefined
      // 成功
      let resolve = (value) => {
        // state改变, resolve调用就会失败
        if (this.state === 'pending') {
          this.state = 'fulfilled'
          this.value = value
        }
      }
      // 失败
      let reject = (reson) => {
        // state改变, reject调用就会失败
        if (state === 'pending') {
          // reject调用后, state转化为失败态
          this.state = 'rejected'
          // 存储失败的原因
          this.reason = reason
        }
      }
      // 如果executor执行报错, 直接执行reject
      try {
        // 立即执行
        executor(resolve, reject)
      } catch (err) {
        reject (err)
      }
    }

    // then 方法 有两个onFulfilled onRejected
    then (onFulfilled, onRejected) {
      // 状态为fulfilled, 执行onFulfilled, 传入成功的值
      if (this.state === fulfilled) {
        onFulfilled(this.value)
      }
      // 状态为rejected, 执行onRejected, 传入失败的原因
      if (this.state === 'rejected') {
        onRejected(this.reason)
      }
    }
  }
```
### 算法: 如何将一组分成两个子集，使两组数字之和的差异最小

动态规划

## 车好多
### 1. 关于函数和函数表达式
函数声明会变量声明提升，提升到顶级作用域

### 2. 响应式布局的实现
rem
https://www.jianshu.com/p/daf1119e187b?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation

### 3. 设计组件的这种思维能力    思维能力？
 1）、先列出来我都有什么功能，每个功能点都是如何实现的
 2）、要对外暴露什么API
 3）、对内传入的参数问题

### 4. 你们是如何进行性能优化的？   
减少HTTP请求（合并js css等）减小文件的体积 压缩等  合理的使用缓存
js css 这些不经常变动的文件如何更新

### 5. Symbol  
ES5的属性名都是字符串这样很容易造成属性名冲突。保证每个属性名称都是独一无二的

## 58同城
### 1. Symbol、Map     
Symbol表示独一无二的值

### 2. webpack打包原理   webpack模块化原理

webpack中一切皆模块
webpack打包的结果是一个立即执行函数，每个模块的代码包在一个函数中作为立即执行函数的参数

  ● webpack4 提倡零配置，但是很多情况下我们还是无法做到零配置，默认了入口文件为./src/index.js 默认打包结果在 ./dist/main.js
  ● mode 参数  设置模式  development 和 production
  ● development模式  开发模式   需要配置webpack-dev-server等
  ● production模式需要配置 UglifyJSPlugin 和 sourcemaps等等
  ● 移除了CommonChunkPlugin    改为在optimazition中配置

webpack 中的tree-shaking    删除掉无用的代码，减小打包的体积
tree-shaking只能在静态modules下面工作。ES6的模块加载是静态的，因此整个依赖树可以被静态的推导出解析语法树

### 3. 算法: Top-k问题：arr  10000个数  求前k大元素

堆排序

### 4. 冒泡

```javascript
  // 冒泡排序
  function BubbleSort (arr) {
    // 外层循环: 控制趟数, 每一次找到一个最大值
    for (let i = 0; i < arr.length; i ++) {
      // 内层循环: 控制比较的次数, 并且判断两个数的大小
      for (let j = 0; j < arr.length - 1 - i; j ++) {
        // 如果前面的数大, 放到后面(当然是从小到大的冒泡排序)
        if (arr[j] > arr[j + 1]) {
          let tempItem = arr[j]
          arr[j] = arr[j + 1]
          arr[j + 1] = tempItem
        }
      }
    }
    return arr
  }
```

## 头条
### 1. vue源码知多少？vue中是如何监听数组的变化的 

重写了数组的方法，所以我们在调用push等方法来改变数组的时候可以触发视图的更新

### 2. vue 源码的模板编译了解吗


### 3. vue 源码diff 算法 是如何进行dom节点对比的  算法知多少？


### 4. 在某次事件循环中操作dom 100次  会变100次吗？   DOM是在什么时候更新的？


### 5. webpack优化相关   按需加载   单页应用如何按需加载的？


### 6. vue何时构建真是的DOM
Vue的Render函数生成虚拟dom，然后会通过dom diff，生成真实dom
这个步骤是patch方法实现的，也就是在mounted之前或者updated之前完成的

### 7. vue服务端渲染了解


### 8. vue双向绑定如何实现的


### 9. webpack 打包优化


### 10. router实现原理

## 面试题

### 1. css: flex: 1, 垂直居中属性

### 2. css兼容性处理

**1px兼容性问题**

一般设计师出图的时候，都会按照一个尺寸作为标准来出图，比如按照iPhone6的尺寸出图，就是一张750px宽的设计图，这个750px其实就是iPhone6的设备像素，在测量设计图时量到的1px其实是1设备像素，而当我们设置<meta name="viewport" content="width=device-width, initial-scale=1">时，布局视口等于理想视口等于375px，并且由于iPhone6的DPR为2，写css时的1px对应的是2设备像素，所以看起来会粗一点。
那么只要写0.5px就是对应1设备像素了嘛。是的，道理是这么说，但是很多浏览器并不支持0.5px的写法，

**解决方案: 伪类 + transform**
```javascript
// 用于容器border, 使用时覆盖border
.border-1px {
  position: relative;
  &::before {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 200%;
    color: rgba(0,0,0,.04);
    height: 200%;
    -webkit-transform-origin: left top;
    transform-origin: left top;
    -webkit-transform: scale(0.5);
    transform: scale(0.5);
    pointer-events: none;
    box-sizing: border-box;
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      width: 300%;
      height: 300%;
      -webkit-transform: scale(0.33333333);
      transform: scale(0.33333333);
    }
  }
}

// 用于底边框，覆盖background
.bottom-1px {
  position: relative;
  &::after {
    content: '';
    display: block;
    width: 100%;
    text-align: right;
    height: 1px;
    background: rgba(0,0,0,0.06);
    position: absolute;
    bottom: 0;
    right: 0;
    transform: scaleY(0.5);
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      transform: scaleY(0.33);
    }
  }
}

// 用于顶边框，覆盖background
.top-1px {
  position: relative;
  &::before {
    content: '';
    display: block;
    width: 100%;
    text-align: right;
    height: 1px;
    background: rgba(0,0,0,0.06);
    position: absolute;
    top: 0;
    right: 0;
    transform: scaleY(0.5);
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      transform: scaleY(0.33);
    }
  }
}

// 用于左边框，覆盖background
.left-1px {
  position: relative;
  &::before {
    content: '';
    display: block;
    width: 1px;
    text-align: right;
    height: 100%;
    background: rgba(0,0,0,0.06);
    position: absolute;
    top: 0;
    left: 0;
    transform: scaleX(0.5);
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      transform: scaleX(0.33);
    }
  }
}
```

**ios滚动卡顿, 头部有晃动**
```javascript
  -webkit-overflow-scrolling: touch;
```

**安卓部分版本input里的placeholder位置偏上**
把input的line-height设为normal
```javascript
  input{
      line-height:normal
  }
```
[参考](https://stackoverflow.com/questions/4919680/html5-placeholder-css-padding)

**ios微信浏览器弹出键盘再收起时，原虚拟键盘位点击事件无效**
```javascript
  document.body.scrollIntoView(false)
```
### 3. vuex为什么要使用action, 有什么原因, 直接使用mutation为什么不行
### 4. 普通函数, 箭头函数, 异步函数, 生产函数的区别
**箭头函数**
1. 箭头函数没有prototype(原型), 所以箭头函数本身没有this
2. this对象就是定义时所在的对象, 而不是使用时所在的对象
3. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
4. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
5. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
6. this的指向是固定的, 不可变的

**异步函数**
1. callback
2. promise
3. async/await

### 5. promise为什么能链式调用, 具体原理
在then中新创建的Promise, 它的状态变为fulfilled的节点是在上一个Promise的回调执行完毕的时候. 也就是说当一个Promise的状态被fulfilled之后, 会执行其回调函数, 而回调函数返回的结果会被当做value, 返回给下一个Promise(也就是then中产生的Promise), 同时下一个Promise的状态也会被改变(执行resolve或reject), 然后再去执行其回调, 以此类推下去...链式调用的效应就出来了

### 6. promise.then(() => {return x}), x是函数, 对象, Promise有什么区别, 如果没有return呢


### 7. 异步函数并行调用方法

**Promise.all**

```javascript
  // 使用Promise.all发送请求
  // 如果中间有一个失败，则进入失败方法
  Promise.all([
      promiseUtil('http://www.baidu.com'),
      promiseUtil('http://www.g.cn'),
  ]).then((data)=>{
      // 执行成功
      console.log('请求成功:');
      //
      let [ data1, data2 ] = data;
      //
      console.log(data1, data2);
  }, (error)=>{
      console.log('请求失败：')
      console.log(error);
  })
```
### 8. 算法: 1-10000的顺序数组打乱, 并且随机删除两个数, 如何知道删除的是哪两个数(从空间耗损考虑)

1-10000相加然后 减去剩余的数 可以得到两个数的和

## 跟谁学2
### 1. 画个三角形

```javascript
  div {
    width: 0;
    height: 0;
    border-bottom: 50px solid red;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
  }
```

### 2. 圣杯布局, flex有哪些属性

```javascript
<body>
  <header>header</header>
  <div class="container">
    <div class="left">left</div>
    <div class="center">center</div>
    <div class="right">right</div>
  </div>
  <footer>footer</footer>
</body>
<style>
  body {
    display: flex;
    flex-direction: column;
    height: 100vh;
    min-width: 800px;
  }
  header, footer {
    background-color: antiquewhite;
  }
  .container {
    display: flex;
    flex: 1;
  }
  .left {
    /* order: -1; */
    flex: 0 0 220px;
    background: yellowgreen;
  }
  .center {
    flex: 1;
  }
  .right {
    flex: 0 0 150px;
    background: yellowgreen;
  }
</style>
```

### 3. rem适配, 为什么使用750的适配尺寸
750的尺寸是iphone6为标准的适配图

### 4. 了解es6么, 举例常用的es6方法

* 数组去重: ...new Set()
```javascript
  let arr = [1, 2, 3, 4, 3, 4]
  let arr2 = [...new Set(arr)]
  // arr2 => [1, 2, 3, 4]
```

* 合并数组: 
```javascript
  let arr1 = ['a', 'b']
  let arr2 = ['c']
  let arr3 = ['d', 'e']
  // ES5的合并: 
  arr1.concat(arr2, arr3)
  // ES6的合并
  [...arr1, ...arr2, ...arr3]
  // ['a', 'b', 'c', 'd', 'e']
```

* 字符串反转: reverse()
```javascript
  let str = '42423423424234324'
  // 原始写法: 
  str.split('').reverse().join('')
  // 展开写法
  [...str].reverse().join('')
```

* 对数组中的所有值求和: reduce
```javascript
  let arr = [1, 2, 3, 444, 5555]
  let sum = arr.reduce((x, y) => x + y)
```

### 5. 箭头函数有什么不同
* 箭头函数的 this 永远指向其上下文的  this ，任何方法都改变不了其指向, 如call(), bind(), apply(); 而普通函数的this指向调用它的那个对象
* 箭头函数不能作为构造函数, 不能使用new

### 6. 了解set, map吗
* Map: 是一组键值对的结构，查找速度快.
```javascript
  // 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：
  let m = new Map([['Tom', 95], ['Lucy', 95], ['Bob', 95]])
  m.get('Tom') // 95

  let m = new Map(); // 空Map
  m.set('Adam', 67); // 添加新的key-value
  m.set('Bob', 59);
  m.has('Adam'); // 是否存在key 'Adam': true
  m.get('Adam'); // 67
  m.delete('Adam'); // 删除key 'Adam'
  m.get('Adam'); // undefined

  // 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
  let m = new Map();
  m.set('Adam', 67);
  m.set('Adam', 88);
  m.get('Adam'); // 88
```

* Set: 无重复key的集合
```javascript
  // 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：
  let s1 = new Set() // 空Set
  let s2 = new Set([1, 2, 3]) // 含1, 2, 3

  // 重复元素在Set中自动被过滤：
  var s = new Set([1, 2, 3, 3, '3']);
  s; // Set {1, 2, 3, "3"}

  // 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：
  s.add(4);
  s; // Set {1, 2, 3, 4}
  s.add(4);
  s; // 仍然是 Set {1, 2, 3, 4}

  // 通过delete(key)方法可以删除元素：
  var s = new Set([1, 2, 3]);
  s; // Set {1, 2, 3}
  s.delete(3);
  s; // Set {1, 2}
```

### 7. 说一下尾递归
**尾调用: 函数的最后一个动作是返回一个函数的调用结果的情形**
**尾函数: 尾调用自身, 称为尾递归**

举例: 斐波那契数列

```javascript
  function fibonacci (n, prev = 0, next = 1) {
    if (n <= 1) {
      return next
    }
    return fibonacci(n - 1, next, prev + next)
  }
```


### 8. var a = [1, 3, 5], b = [2, 3, 6]; 求a和b的交集, 并集(可以使用set实现)
一般都是用loadash中封装好的方法
* 并集:
```javascript
  // 方法一: 
  [...new Set(a.concat(b))]
  // 方法二: 
  a.concat(b.filter(item => !a.includes(item)))
```

* 交集:
```javascript
  a.filter(item => b.includes(item))
```

### 9. 短除法10的二进制是多少? 用函数实现


### 10. 实现一个斐波那契函数

* 尾递归: 函数尾调用自身, 就成为尾递归
```javascript
    // 方法一: 递归(普通版)
    function fibonacci (n) {
      if (n <= 1) {
        return 1
      }
      return fibonacci(n - 1) + fibonacci(n - 2)
    }
    // console.log(fibonacci(10)) // 89
    // console.log(fibonacci(100)) // 堆栈溢出
    // console.log(fibonacci(500)) // 堆栈溢出

    // 方法二: 递归(优化版)
    function fibonacci2 (n, prev = 0, next = 1) {
      if (n <= 1) {
        return next
      }
      return fibonacci2(n - 1, next, prev + next)
    }
    console.log(fibonacci2(10)) // 89
    console.log(fibonacci2(100)) // 堆栈溢出
    console.log(fibonacci2(1000)) // 堆栈溢出
```

### 11. 正则表达式13411112345 -> 134***3333
```javascript
  '12345678901'.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2')
  // 输出: 123****8901
```

### 12. 了解node么, node是干什么的, node常用的框架
node是服务端语言

### 13. 说一下node的事件循环机制
### 15. new实际执行了哪些操作
* 得到私有属性
* 使实例对象的原型链等于构造函数的原型

```javascript
  // 声明一个函数
  var Person = function (options) {
    // 有一个私有尚需经
    this.sex = options.sex
  }
  // 公共属性prototype里加入一个方法
  Person.prototype.getSex = function () {
    return this.sex
  }
  // new Person
  var p = new Person({sex: 'man})

    // new了之后可以得到以下信息: 
  	// p 的 构造函数 是 Person 
    // 因为: 这是规则
    console.log(p.constructor === Person); // true

    
    // p 是 Person 这个构造函数的 实例对象
    // 因为: 这是规则
    console.log(p instanceof Person); // true
    
    new 做了几件事? 
    '这是new 做的第一件事', 得到私有属性
			// p 可以调用私有属性 sex
			// 说对象时候说过, 私有属性, 就是这个对象下自己有的属性, p.hasOwnProperty('属性名') === true , 就表示p下面有这个私有属性
			console.log(p.sex);
			console.log(p.hasOwnProperty('sex')); // true
			console.log(p.hasOwnProperty('getSex')); // false 表示p下面没有这个属性, 那么 p.getSex() 可以调用到么? 那就要看new做的 第二个件事了

			'这是new 做的第二件事': p.__proto__ === Person.prototype
			// p 可以调用公有方法 getSex
			// 因为 p 可以 通过原型链 找到 Person.prototype下面的方法 getSex
			console.log(p.getSex());
			console.log(p.__proto__ === Person.prototype); // true
			
			p的结构如下图, 'new 之后的结构要知道' 
			p: {
				sex: 'man',
				__proto__: {
					constructor: Person,
					getSex: function () {

					},
					__proto__: Object
				}
			}
```

### 16. vue的生命周期


### 17. vue解决过什么坑


### 18. webpack打包速度优化



