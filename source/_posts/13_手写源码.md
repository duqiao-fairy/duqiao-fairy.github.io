---
title: 手写源码
---

---
title: 常见面试题
---

## 转转
### 1、rem布局

rem是css的长度单位, 它是相对于<html>元素的font-size的相对值. 假设html{ font-size: 20px; }, 那么1rem就等于20px.

```javascript
1rem === html的font-size
```
其实rem布局的本质是等比缩放，一般是基于宽度.

### 2. 项目上线系统的原理是什么

我们的上线系统有两套, 一个是def, 一个是faas

## 跟谁学
### 1. 跨域如何解决
jsonp跨域: 
待补充

cors跨域：
整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。
因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

1）简单请求
请求方法：get、post、head
请求头：accept、accept-language、content-language、content-type（application/x-www-form-urlencoded、multipart/form-data、text/plain）

简单请求，浏览器直接发出跨域请求，直接在头信息中添加origin字段

2）非简单请求
先发一个预检请求，来让服务器确认是否支持发送这样的请求
预检请求的request header 会有以下几个头信息：
origin
access-control-allow-method：
access-control-allow-header：额外发送的请求字段


### 2. 实现轮播图组件


### 3. 手写js map函数

```javascript
  Array.prototype.MyMap = function (fn, context) {
    // 能将具有length属性的对象转成数组
    let arr = Array.prototype.slice.call(this)
    let newArr = []
    for(let i = 0; i < arr.length; i ++) {
      newArr.push(fn.call(context, arr[i], i, this))
    }
    return newArr
  }
```

### 4. 深拷贝

**1) 浅拷贝**
1. Object.assign()
2. Array.prototype.cancat()
3. Array.prototype.slice() 

**2) 深拷贝**
1. JSON.parse(JSON.stringify())
原理: 用JSON.stringfy将对象转成JSON字符串, 再用JSON.parse()把字符串解析成对象, 一去一来, 新的对象产生了, 而且对象会开辟新的栈, 实现深拷贝.
注意: 这种方法虽然可以实现数组或对象深拷贝, 但不能处理函数.

2. 手写递归方法
递归方法实现深度克隆原理: 遍历对象, 数组直到里面都是基本数据类型, 然后再去复制, 就是深度拷贝
```javascript
  function deepClone (obj) {
    // 1. 判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝
    // 第一种方法
    // var objClone = Array.inArray(obj) ? [] : {}
    // 第二种方法
    // var objClone = obj instanceof Array ? [] : {}
    // 第三种方法
    var objClone = obj.constructor === Array ? [] : {}

    for(let k in obj) {
      if(typeof obj[k] === 'object') {
        objClone[k] = deepClone(obj[k])
      } else {
        objClone[k] = obj[k]
      }
    }
    return objClone
  }
```


3. 函数库lodash
该函数库也有提供_.cloneDeep用来做Deep Copy

### 5. textarea 设置padding好像有什么问题？这个好像我没怎么遇见


## 小米

### 1. 深克隆(可能会有数组的)
注意点：
1）、实现方案   JSON.parse + JSON.stringify  问题：无法实现对function、RegExp等特殊对象的克隆
2）、会抛弃对象的constructor,所有的构造函数会指向Object
3）、对象有循环引用,会报错

### 2. bind的实现

```javascript
  Function.prototype.myBind = function(oThis) {
    if (typeof this != 'function') {
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable')
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNop = function() {},
    fBound = function() {
      return fToBind.apply(
        this instanceof fBound ? this : oThis,
        aArgs.concat(Array.prototype.slice.call(arguments))
      )
    }

    if (this.prototype) {
      fNop.prototype = this.prototype
    }
    fBound.prototype = new fNop()
    return fBound
  }
```

### 3. ES6的 Generator async await

1) Generator函数是ES6提供的一种异步变成解决方案, 是一个状态机, 封装了多个内部状态.

执行generator函数返回的是一个遍历器对象, 也就是说, 我们可以使用next方法, 来遍历generator函数内部的每一个状态.

既然generator函数内部具有多个状态, 那么总该有一个标识来决定函数在遍历过程中应该在哪里停下来, 所以我们需要yield.

2) async 函数是什么 ? 一句话, 他就是 Generator函数的语法糖

### 4. 简单算法 两个有序子数组，合并成一个数组，如何实现，降低时间复杂度那种

```javascript
  // 方法一: 
  function concatArrs(arr1, arr2) {
    const arr = arr1.concat(arr2)
    return arr.sort((a, b) => {
      return a - b
    })
  }
  console.log(concatArrs([1, 2, 5], [1, 4, 6]))

  // 方法二: 
  function concatArrs2(arr1, arr2) {
    let index1 = 0 // 标记arr1的对比元素的初始索引值
    let index2 = 0 // 标记arr2的对比元素的初始索引值
    let newArr = [] // 作为输出的新数组

    // 当arr1 和 arr2元素均未全部存入arr中, 则从数组第一个元素开始进行比较, 将较小的元素存入newArr中
    while (index1 < arr1.length && index2 < arr2.length) {
      if (arr1[index1] <= arr2[index2]) { // 若arr1元素小于arr2元素, 则将arr1的元素存入newArr中
        newArr.push(arr1.slice(index1)[0]) // 已将元素push到输出数组中, 将数组arr1的index指向移动到下一个
        index1 ++
      } else {
        newArr.push(arr2.slice(index2)[0])
        index2 ++
      }
    }
    // 当不满足上述while条件(index1 < arr1.length && index2 < arr1.length)时, 就直接将剩余数组元素拼接输出数组newArr后面
    return newArr.concat(index1 < arr1.length ? arr1.slice(index1) : arr2.slice(index2))
  }

  console.log(concatArrs2([1, 2, 5], [1, 4, 6]))
```

### 5. es6的class会继承static的属性吗


## 搜狐
### 1. 写一个jsonp，jsonp的返回值是什么？

### 2. BFC

BFC: 块级格式化上下文, 是css布局的一个概念, 它是页面中的一块渲染区域, 有一套渲染规则, 决定了其子元素如何布局, 以及和其他元素之间的关系和作用.

通俗解释: BFC可以简单的理解为某个元素的一个CSS属性, 只不过这个属性不能被开发者显示的修改, 拥有这个属性的元素对内部元素和外部元素会表现出一些特性, 这就是BFC

触发条件或者说哪些元素会生成BFC：
满足下列条件之一就可触发BFC
　　【1】根元素，即HTML元素
　　【2】float的值不为none
　　【3】overflow的值不为visible
　　【4】display的值为inline-block、table-cell、table-caption
　　【5】position的值为absolute或fixed


BFC布局规则：
1.内部的Box会在垂直方向，一个接一个地放置。
2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
4.BFC的区域不会与float box重叠。
5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6.计算BFC的高度时，浮动元素也参与计算

BFC布局规则：
1.内部的Box会在垂直方向，一个接一个地放置。
2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
4.BFC的区域不会与float box重叠。
5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6.计算BFC的高度时，浮动元素也参与计算

BFC有哪些作用：
1. 自适应两栏布局
2. 可以阻止元素被浮动元素覆盖
3. 可以包含浮动元素——清除内部浮动
4. 分属于不同的BFC时可以阻止margin重叠

### 3. Promise实现原理, 动手实现Promise

```javascript
  class MyPromise {
    // 构造器
    constructor (executor) {
      // 初始化state为等待态
      this.state = 'pending'
      // 成功的值
      this.value = undefined
      // 失败的原因
      this.reason = undefined
      // 成功
      let resolve = (value) => {
        // state改变, resolve调用就会失败
        if (this.state === 'pending') {
          this.state = 'fulfilled'
          this.value = value
        }
      }
      // 失败
      let reject = (reson) => {
        // state改变, reject调用就会失败
        if (state === 'pending') {
          // reject调用后, state转化为失败态
          this.state = 'rejected'
          // 存储失败的原因
          this.reason = reason
        }
      }
      // 如果executor执行报错, 直接执行reject
      try {
        // 立即执行
        executor(resolve, reject)
      } catch (err) {
        reject (err)
      }
    }

    // then 方法 有两个onFulfilled onRejected
    then (onFulfilled, onRejected) {
      // 状态为fulfilled, 执行onFulfilled, 传入成功的值
      if (this.state === fulfilled) {
        onFulfilled(this.value)
      }
      // 状态为rejected, 执行onRejected, 传入失败的原因
      if (this.state === 'rejected') {
        onRejected(this.reason)
      }
    }
  }
```
### 算法: 如何将一组分成两个子集，使两组数字之和的差异最小

动态规划

## 车好多
### 1. 关于函数和函数表达式
函数声明会变量声明提升，提升到顶级作用域

### 2. 响应式布局的实现
rem
https://www.jianshu.com/p/daf1119e187b?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation

### 3. 设计组件的这种思维能力    思维能力？
 1）、先列出来我都有什么功能，每个功能点都是如何实现的
 2）、要对外暴露什么API
 3）、对内传入的参数问题

### 4. 你们是如何进行性能优化的？   
减少HTTP请求（合并js css等）减小文件的体积 压缩等  合理的使用缓存
js css 这些不经常变动的文件如何更新

### 5. Symbol  
ES5的属性名都是字符串这样很容易造成属性名冲突。保证每个属性名称都是独一无二的

## 58同城
### 1. Symbol、Map     
Symbol表示独一无二的值

### 2. webpack打包原理   webpack模块化原理

webpack中一切皆模块
webpack打包的结果是一个立即执行函数，每个模块的代码包在一个函数中作为立即执行函数的参数

  ● webpack4 提倡零配置，但是很多情况下我们还是无法做到零配置，默认了入口文件为./src/index.js 默认打包结果在 ./dist/main.js
  ● mode 参数  设置模式  development 和 production
  ● development模式  开发模式   需要配置webpack-dev-server等
  ● production模式需要配置 UglifyJSPlugin 和 sourcemaps等等
  ● 移除了CommonChunkPlugin    改为在optimazition中配置

webpack 中的tree-shaking    删除掉无用的代码，减小打包的体积
tree-shaking只能在静态modules下面工作。ES6的模块加载是静态的，因此整个依赖树可以被静态的推导出解析语法树

### 3. 算法: Top-k问题：arr  10000个数  求前k大元素

堆排序

### 4. 冒泡

```javascript
  // 冒泡排序
  function BubbleSort (arr) {
    // 外层循环: 控制趟数, 每一次找到一个最大值
    for (let i = 0; i < arr.length; i ++) {
      // 内层循环: 控制比较的次数, 并且判断两个数的大小
      for (let j = 0; j < arr.length - 1 - i; j ++) {
        // 如果前面的数大, 放到后面(当然是从小到大的冒泡排序)
        if (arr[j] > arr[j + 1]) {
          let tempItem = arr[j]
          arr[j] = arr[j + 1]
          arr[j + 1] = tempItem
        }
      }
    }
    return arr
  }
```

## 头条
### 1. vue源码知多少？vue中是如何监听数组的变化的 

重写了数组的方法，所以我们在调用push等方法来改变数组的时候可以触发视图的更新

### 2. vue 源码的模板编译了解吗


### 3. vue 源码diff 算法 是如何进行dom节点对比的  算法知多少？


### 4. 在某次事件循环中操作dom 100次  会变100次吗？   DOM是在什么时候更新的？


### 5. webpack优化相关   按需加载   单页应用如何按需加载的？


### 6. vue何时构建真是的DOM
Vue的Render函数生成虚拟dom，然后会通过dom diff，生成真实dom
这个步骤是patch方法实现的，也就是在mounted之前或者updated之前完成的

### 7. vue服务端渲染了解


### 8. vue双向绑定如何实现的


### 9. webpack 打包优化


### 10. router实现原理

## 面试题

### 1. css: flex: 1, 垂直居中属性

### 2. css兼容性处理

**1px兼容性问题**

一般设计师出图的时候，都会按照一个尺寸作为标准来出图，比如按照iPhone6的尺寸出图，就是一张750px宽的设计图，这个750px其实就是iPhone6的设备像素，在测量设计图时量到的1px其实是1设备像素，而当我们设置<meta name="viewport" content="width=device-width, initial-scale=1">时，布局视口等于理想视口等于375px，并且由于iPhone6的DPR为2，写css时的1px对应的是2设备像素，所以看起来会粗一点。
那么只要写0.5px就是对应1设备像素了嘛。是的，道理是这么说，但是很多浏览器并不支持0.5px的写法，

**解决方案: 伪类 + transform**
```javascript
// 用于容器border, 使用时覆盖border
.border-1px {
  position: relative;
  &::before {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 200%;
    color: rgba(0,0,0,.04);
    height: 200%;
    -webkit-transform-origin: left top;
    transform-origin: left top;
    -webkit-transform: scale(0.5);
    transform: scale(0.5);
    pointer-events: none;
    box-sizing: border-box;
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      width: 300%;
      height: 300%;
      -webkit-transform: scale(0.33333333);
      transform: scale(0.33333333);
    }
  }
}

// 用于底边框，覆盖background
.bottom-1px {
  position: relative;
  &::after {
    content: '';
    display: block;
    width: 100%;
    text-align: right;
    height: 1px;
    background: rgba(0,0,0,0.06);
    position: absolute;
    bottom: 0;
    right: 0;
    transform: scaleY(0.5);
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      transform: scaleY(0.33);
    }
  }
}

// 用于顶边框，覆盖background
.top-1px {
  position: relative;
  &::before {
    content: '';
    display: block;
    width: 100%;
    text-align: right;
    height: 1px;
    background: rgba(0,0,0,0.06);
    position: absolute;
    top: 0;
    right: 0;
    transform: scaleY(0.5);
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      transform: scaleY(0.33);
    }
  }
}

// 用于左边框，覆盖background
.left-1px {
  position: relative;
  &::before {
    content: '';
    display: block;
    width: 1px;
    text-align: right;
    height: 100%;
    background: rgba(0,0,0,0.06);
    position: absolute;
    top: 0;
    left: 0;
    transform: scaleX(0.5);
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      transform: scaleX(0.33);
    }
  }
}
```

**ios滚动卡顿, 头部有晃动**
```javascript
  -webkit-overflow-scrolling: touch;
```

**安卓部分版本input里的placeholder位置偏上**
把input的line-height设为normal
```javascript
  input{
      line-height:normal
  }
```
[参考](https://stackoverflow.com/questions/4919680/html5-placeholder-css-padding)

**ios微信浏览器弹出键盘再收起时，原虚拟键盘位点击事件无效**
```javascript
  document.body.scrollIntoView(false)
```
### 3. vuex为什么要使用action, 有什么原因, 直接使用mutation为什么不行
### 4. 普通函数, 箭头函数, 异步函数, 生产函数的区别
**箭头函数**
1. 箭头函数没有prototype(原型), 所以箭头函数本身没有this
2. this对象就是定义时所在的对象, 而不是使用时所在的对象
3. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
4. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
5. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
6. this的指向是固定的, 不可变的

**异步函数**
1. callback
2. promise
3. async/await

### 5. promise为什么能链式调用, 具体原理
在then中新创建的Promise, 它的状态变为fulfilled的节点是在上一个Promise的回调执行完毕的时候. 也就是说当一个Promise的状态被fulfilled之后, 会执行其回调函数, 而回调函数返回的结果会被当做value, 返回给下一个Promise(也就是then中产生的Promise), 同时下一个Promise的状态也会被改变(执行resolve或reject), 然后再去执行其回调, 以此类推下去...链式调用的效应就出来了

### 6. promise.then(() => {return x}), x是函数, 对象, Promise有什么区别, 如果没有return呢


### 7. 异步函数并行调用方法

**Promise.all**

```javascript
  // 使用Promise.all发送请求
  // 如果中间有一个失败，则进入失败方法
  Promise.all([
      promiseUtil('http://www.baidu.com'),
      promiseUtil('http://www.g.cn'),
  ]).then((data)=>{
      // 执行成功
      console.log('请求成功:');
      //
      let [ data1, data2 ] = data;
      //
      console.log(data1, data2);
  }, (error)=>{
      console.log('请求失败：')
      console.log(error);
  })
```
### 8. 算法: 1-10000的顺序数组打乱, 并且随机删除两个数, 如何知道删除的是哪两个数(从空间耗损考虑)

1-10000相加然后 减去剩余的数 可以得到两个数的和

## 跟谁学2
### 1. 画个三角形

```javascript
  div {
    width: 0;
    height: 0;
    border-bottom: 50px solid red;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
  }
```

### 2. 圣杯布局, flex有哪些属性

```javascript
<body>
  <header>header</header>
  <div class="container">
    <div class="left">left</div>
    <div class="center">center</div>
    <div class="right">right</div>
  </div>
  <footer>footer</footer>
</body>
<style>
  body {
    display: flex;
    flex-direction: column;
    height: 100vh;
    min-width: 800px;
  }
  header, footer {
    background-color: antiquewhite;
  }
  .container {
    display: flex;
    flex: 1;
  }
  .left {
    /* order: -1; */
    flex: 0 0 220px;
    background: yellowgreen;
  }
  .center {
    flex: 1;
  }
  .right {
    flex: 0 0 150px;
    background: yellowgreen;
  }
</style>
```

### 3. rem适配, 为什么使用750的适配尺寸
750的尺寸是iphone6为标准的适配图

### 4. 了解es6么, 举例常用的es6方法

* 数组去重: ...new Set()
```javascript
  let arr = [1, 2, 3, 4, 3, 4]
  let arr2 = [...new Set(arr)]
  // arr2 => [1, 2, 3, 4]
```

* 合并数组: 
```javascript
  let arr1 = ['a', 'b']
  let arr2 = ['c']
  let arr3 = ['d', 'e']
  // ES5的合并: 
  arr1.concat(arr2, arr3)
  // ES6的合并
  [...arr1, ...arr2, ...arr3]
  // ['a', 'b', 'c', 'd', 'e']
```

* 字符串反转: reverse()
```javascript
  let str = '42423423424234324'
  // 原始写法: 
  str.split('').reverse().join('')
  // 展开写法
  [...str].reverse().join('')
```

* 对数组中的所有值求和: reduce
```javascript
  let arr = [1, 2, 3, 444, 5555]
  let sum = arr.reduce((x, y) => x + y)
```

### 5. 箭头函数有什么不同
* 箭头函数的 this 永远指向其上下文的  this ，任何方法都改变不了其指向, 如call(), bind(), apply(); 而普通函数的this指向调用它的那个对象
* 箭头函数不能作为构造函数, 不能使用new

### 6. 了解set, map吗
* Map: 是一组键值对的结构，查找速度快.
```javascript
  // 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：
  let m = new Map([['Tom', 95], ['Lucy', 95], ['Bob', 95]])
  m.get('Tom') // 95

  let m = new Map(); // 空Map
  m.set('Adam', 67); // 添加新的key-value
  m.set('Bob', 59);
  m.has('Adam'); // 是否存在key 'Adam': true
  m.get('Adam'); // 67
  m.delete('Adam'); // 删除key 'Adam'
  m.get('Adam'); // undefined

  // 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
  let m = new Map();
  m.set('Adam', 67);
  m.set('Adam', 88);
  m.get('Adam'); // 88
```

* Set: 无重复key的集合
```javascript
  // 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：
  let s1 = new Set() // 空Set
  let s2 = new Set([1, 2, 3]) // 含1, 2, 3

  // 重复元素在Set中自动被过滤：
  var s = new Set([1, 2, 3, 3, '3']);
  s; // Set {1, 2, 3, "3"}

  // 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：
  s.add(4);
  s; // Set {1, 2, 3, 4}
  s.add(4);
  s; // 仍然是 Set {1, 2, 3, 4}

  // 通过delete(key)方法可以删除元素：
  var s = new Set([1, 2, 3]);
  s; // Set {1, 2, 3}
  s.delete(3);
  s; // Set {1, 2}
```

### 7. 说一下尾递归
**尾调用: 函数的最后一个动作是返回一个函数的调用结果的情形**
**尾函数: 尾调用自身, 称为尾递归**

举例: 斐波那契数列

```javascript
  function fibonacci (n, prev = 0, next = 1) {
    if (n <= 1) {
      return next
    }
    return fibonacci(n - 1, next, prev + next)
  }
```


### 8. var a = [1, 3, 5], b = [2, 3, 6]; 求a和b的交集, 并集(可以使用set实现)
一般都是用loadash中封装好的方法
* 并集:
```javascript
  // 方法一: 
  [...new Set(a.concat(b))]
  // 方法二: 
  a.concat(b.filter(item => !a.includes(item)))
```

* 交集:
```javascript
  a.filter(item => b.includes(item))
```

### 9. 短除法10的二进制是多少? 用函数实现


### 10. 实现一个斐波那契函数

* 尾递归: 函数尾调用自身, 就成为尾递归
```javascript
    // 方法一: 递归(普通版)
    function fibonacci (n) {
      if (n <= 1) {
        return 1
      }
      return fibonacci(n - 1) + fibonacci(n - 2)
    }
    // console.log(fibonacci(10)) // 89
    // console.log(fibonacci(100)) // 堆栈溢出
    // console.log(fibonacci(500)) // 堆栈溢出

    // 方法二: 递归(优化版)
    function fibonacci2 (n, prev = 0, next = 1) {
      if (n <= 1) {
        return next
      }
      return fibonacci2(n - 1, next, prev + next)
    }
    console.log(fibonacci2(10)) // 89
    console.log(fibonacci2(100)) // 堆栈溢出
    console.log(fibonacci2(1000)) // 堆栈溢出
```

### 11. 正则表达式13411112345 -> 134***3333
```javascript
  '12345678901'.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2')
  // 输出: 123****8901
```

### 12. 了解node么, node是干什么的, node常用的框架
node是服务端语言

### 13. 说一下node的事件循环机制
### 15. new实际执行了哪些操作
* 得到私有属性
* 使实例对象的原型链等于构造函数的原型

```javascript
  // 声明一个函数
  var Person = function (options) {
    // 有一个私有尚需经
    this.sex = options.sex
  }
  // 公共属性prototype里加入一个方法
  Person.prototype.getSex = function () {
    return this.sex
  }
  // new Person
  var p = new Person({sex: 'man})

    // new了之后可以得到以下信息: 
  	// p 的 构造函数 是 Person 
    // 因为: 这是规则
    console.log(p.constructor === Person); // true

    
    // p 是 Person 这个构造函数的 实例对象
    // 因为: 这是规则
    console.log(p instanceof Person); // true
    
    new 做了几件事? 
    '这是new 做的第一件事', 得到私有属性
			// p 可以调用私有属性 sex
			// 说对象时候说过, 私有属性, 就是这个对象下自己有的属性, p.hasOwnProperty('属性名') === true , 就表示p下面有这个私有属性
			console.log(p.sex);
			console.log(p.hasOwnProperty('sex')); // true
			console.log(p.hasOwnProperty('getSex')); // false 表示p下面没有这个属性, 那么 p.getSex() 可以调用到么? 那就要看new做的 第二个件事了

			'这是new 做的第二件事': p.__proto__ === Person.prototype
			// p 可以调用公有方法 getSex
			// 因为 p 可以 通过原型链 找到 Person.prototype下面的方法 getSex
			console.log(p.getSex());
			console.log(p.__proto__ === Person.prototype); // true
			
			p的结构如下图, 'new 之后的结构要知道' 
			p: {
				sex: 'man',
				__proto__: {
					constructor: Person,
					getSex: function () {

					},
					__proto__: Object
				}
			}
```

### 16. vue的生命周期


### 17. vue解决过什么坑


### 18. webpack打包速度优化

## 美术宝
1. webpack做过什么的优化
2. new做了什么
3. 跨域方案
4. 如何判断对象类型
5. promise原理
6. es6用过的方法
7. 盒子模型
8. css 上下左右居中
9. 判断类型方式
10. 闭包的应用
11. react ref
12. vue改变属性的方法
13. webRTC?
14. 作用域的理解
15. 如何理解原型原型链
16. typeof null 返回什么

## 新氧
### 1. DOM事件三个阶段

**事件流描述的是从页面中接收事件的顺序**

DOM2级事件规定的事件流包括三个阶段:
- 事件捕获阶段: 在事件冒泡的模型中，捕获阶段不会响应任何事件;
- 处于目标阶段: 目标阶段就是指事件响应到触发事件的最底层元素上;
- 事件冒泡阶段: 冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；

### 2. js事件委托
**事件委托就是利用冒泡的原理, 把事件加到父元素或祖先元素上, 触发执行效果.**
优点: 减少内存消耗

### 3. webpack热更新原理
### 4. 前端工程化的理解

### 5. XSS, CSRF
1. XSS: 跨站脚本攻击
  (1) 原理: 页面渲染的数据包含可运行的脚本
  (2) 攻击类型: 反射型(url参数直接注入)和存储型(存储到DB后读取时注入)
  (3) 防御: 
          - 对不可信的数据源, 进行特殊字符的转义
          - 将重要的cookie标记为http only
          - 直接过滤掉javascript事件标签和一些特殊的html标签

2. CSRF: 跨站请求伪造
  (1) 原理: 在第三方网站向本网站发起请
  (2) 攻击类型: 攻击者盗用你的身份, 以你的名义发送恶意请求, 盗取账号等.
  (3) 防御: 在请求地址中添加token并验证


### 6. css 上下左右居中
```javascript
  /* 方法一: transform */  
  .wrap {
    width: 500px;
    height: 500px;
    border: 1px solid #000;
  }
  .content {
    position: relative;
    left: 50%;
    top: 50%;
    width: 200px;
    height: 200px;
    transform: translate(-50%,-50%);
    border: 1px solid blue;
  }

  /* 方法二: 绝对定位 */
  .wrap {
    position: relative;
    width: 500px;
    height: 500px;
    border: 1px solid #000;
  }
  .content {
    position: absolute;
    margin: auto;
    width: 200px;
    height: 200px;
    top:0;
    right:0;
    bottom:0;
    left:0;
    border: 1px solid blue;
  }

  /* 方法三: Flex */
  .wrap {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 500px;
    height: 500px;
    border: 1px solid #000;
  }
  .content {
    width: 200px;
    height: 200px;
    border: 1px solid blue;
  }
```

### 7. es6的for of和for in

- for of 可以直接遍历数组中的每一项

```javascript
var arr = [1, 2, 3]
for (let i in arr) {
  console.log(i) // 0, 1, 2
}
for (let i of arr) {
  console.log(i) // 1, 2, 3
}
```
### 8. es6声明变量方式和es5有什么不同
### 9. 平时做的性能优化
### 10. mvvm框架的理解

    model -> view
    view -> model
    整个过程都是响应式的, 用户只需要考虑数据就可以了, 不需要再关心视图的变化

### 11. v-model原理
### 12. es6的class
### 13. cookie session localstorage的不同
### 14. 1px解决方案
### 15. 移动端开发的时候, 如何转换px? dpr原理?

## 广联达
### 1. react原理
react是一个用户构建用户页面的js库, 相当于MVC架构中的V层框架, 与市面上的其他框架不同的是React把每个组件德昂成了一个状态,机 组件内部通过state来维护组件状态的变化, 当组件的状态发生变化时, React通过虚拟DOM技术来高效并增量更新真实的DOM 

**虚拟DOM**
React为此引入了虚拟DOM（Virtual DOM）机制，对于每个组件，React会在内存中构建一个相对应的DOM树，基于React开发时所有的DOM结构都是通过虚拟DOM进行，每当组件的状态发生变化时，React都会重新构建整个DOM数据，然后将当前的整个DOM树和上一次的DOM树进行对比，得出DOM结构变化的部分（Patchs）,然后将这些Patchs在更新到真实的DOM中。整个过程都是在内存中进行。因此是非常高效的。

### 2. react生命周期

- 挂载阶段: 
constructor(props): 实例化
componentWillMount: 用的比较少, 还未渲染DOM
render: 渲染, render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。
componentDidMount: 完成挂载, DOM节点已经生成, 在这里调用ajax请求, 返回数据setState组件会重新渲染.

- 更新阶段: 
componentWillReceiveProps(nextProps): 父组件改变后的props需要重新渲染组件时 接收一个参数nextProps,通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件
shouldComponentUpdate: 判断是否需要重绘
  1. 主要用于性能优化(部分更新)
  2. 唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新
  3. 因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断

componentWillUpdate(nextProps, nextState): shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。
componentDidUpdate(prevProps,prevState): 组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。

- 卸载阶段:
componentWillUnmount: 组件的卸载和数据的销毁, clear素有的setTimeout等, 移出所有的监听 

### 3. refs
**refs是一个获取DOM阶段或React元素实例的工具.**
使用场景:
  1. 对DOM元素焦点的控制, 内容选择或者媒体播放
  2. 通过对DOM元素控制，触发动画特效；
  3. 通第三方DOM库的集成

使用方式: 
  1. React.createRef(): 创建了一个实例属性 this.tRef, 并将其 传递给 DOM元素 div。后续对该节点的引用就可以在ref的 current属性中访问。ref的值根据节点类型的不同结果也不同
  注意: 不能在函数组件上使用ref属性, 因为他们没有实例
  2. 回调Refs

### 4. DOM树和渲染树的区别

**浏览器解析过程:**
  - DNS域名解析: 把域名解析成IP地址, 先查浏览器缓存 -> 本地的host文件 -> 本地域名解析服务器 -> 上一层域名解析服务器 直到找到.
  - TCP连接: 在http消息发送前，需要建立客户端与服务器的TCP链接，也就是进行所谓的**三次握手**。
  - 发送HTTP请求
  - 服务器处理请求并返回HTTP报文
  - 浏览器渲解析渲染过程: 当浏览器获得一个html文件时, 会“自上而下”加载，并在加载过程中进行解析渲染。
      1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
      2. 将CSS解析成 CSS Rule Tree 。
      3. 根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering 3. Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。

5. 一个元素绑定两个事件, 一个捕获, 一个冒泡, 先执行哪个
6. react render函数是怎么执行的, ajax放到哪里执行? 为什么? 说下全过程
7. react遇到的坑
7. flux
8. react-router不同版本有一个什么不同?
9. 如果后端返回的接口的数据格式有问题? 怎么解决?
10. 如果react组件不能满足当前开发任务, 怎么解决?
11. 最近在看的新技术
12. 项目中的性能优化
13. 箭头函数和普通函数的区别
14. 在写高阶组件的时候需要注意什么






