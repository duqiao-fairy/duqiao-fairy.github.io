---
title: js设计模式
---

## 1. 观察者模式(observer)

应用: vue的双向数据绑定MVVM

vue的双向数据绑定原理: 通过数据劫持以及结合发布者-订阅者来实现的数据绑定，数据劫持是利用ES5的Object.defineProperty(obj, key, val)来劫持各个属性的的setter以及getter，在数据变动时发布消息给订阅者，从而触发相应的回调来更新视图。

```javascript
  // 目标者
  class Subject {
    constructor () {
      this.observers = [] // 观察者列表
    }
    
    // 添加订阅者
    add(observer) {
      this.observers.push(observer)
    }

    // 删除
    remove(observer) {
      let idx = this.observers.findIndex(item => item === observer)
      idx > -1 && this.observers.splice(idx, 1)
    }

    // 通知
    notify() {
      for (let o of this.observers) {
        o.update()
      }
    }
  }

  // 观察者
  class Observer {
    constructor(name) {
      this.name = name
    }

    // 目标对象更新时触发的回调, 即收到更新通知后的回调
    update() {
      console.log(`目标者通知我更新了, 我是: ${this.name}`)
    }
  }

  // 实例化目标者
  let subject = new Subject()

  // 实例化两个观察者
  let obs1 = new Observer('前端')
  let obs2 = new Observer('后端')

  // 向目标者添加观察者
  subject.add(obs1)
  subject.add(obs2)

  subject.notify()
```

## 2. 发布订阅模式(Publisher && Subscriber)
```javascript
  // 使用js代码实现一个事件类Event, 包含以下功能: 绑定事件, 解绑事件和派发事件
  class Event {
    constructor() {
      // 存储事件的数据结构
      // 为了查找迅速, 使用了对象(字典)
      this._cache = {}   
    }

    // 绑定
    on(type, callback) {
      // 为了按类查找方便和节省空间, 将同一类型事件放到一个数组中
      // 这里的数组是队列, 遵循先进先出
      // 即先绑定的事件先出发
      let fns = (this._cache[type] = this._cache[type] || [])
      if (fns.indexOf(callback) === -1) {
        fns.push(callback)
      }
      return this
    }

    // 触发
    trigger(type, data) {
      let fns = this._cache[type]
      if(Array.isArray(fns)) {
        fns.forEach((fn) => {
          fn(data)
        })
      }
      return this
    }

    // 解绑
    off(type, callback) {
      let fns = this._cache[type]
      if(Array.isArray(fns)) {
        if (callback) {
          let index = fns.indexOf(callback)
          if (index !== -1) {
            fns.splice(index, 1)
          }
        } else {
          // 全部清空
          fns.length = 0
        }
      }
      return this
    }
  }

  const event = new Event()
  event.on('test', (a) => {
    console.log(a)
  })
  event.trigger('test', 'hello world')

  event.off('test')
```
