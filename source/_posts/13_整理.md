---
title: 整理
date: 2018-06-20 14:39:37
---

## 转转
### 1、rem布局

rem是css的长度单位, 它是相对于<html>元素的font-size的相对值. 假设html{ font-size: 20px; }, 那么1rem就等于20px.

```javascript
1rem === html的font-size
```
其实rem布局的本质是等比缩放，一般是基于宽度.

### 2. 项目上线系统的原理是什么

我们的上线系统有两套, 一个是def, 一个是faas

## 跟谁学
### 1. 跨域如何解决
jsonp跨域: 
待补充

cors跨域：
整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。
因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

1）简单请求
请求方法：get、post、head
请求头：accept、accept-language、content-language、content-type（application/x-www-form-urlencoded、multipart/form-data、text/plain）

简单请求，浏览器直接发出跨域请求，直接在头信息中添加origin字段

2）非简单请求
先发一个预检请求，来让服务器确认是否支持发送这样的请求
预检请求的request header 会有以下几个头信息：
origin
access-control-allow-method：
access-control-allow-header：额外发送的请求字段


### 2. 实现轮播图组件


### 3. 手写js map函数

```javascript
  Array.prototype.MyMap = function (fn, context) {
    // 能将具有length属性的对象转成数组
    let arr = Array.prototype.slice.call(this)
    let newArr = []
    for(let i = 0; i < arr.length; i ++) {
      newArr.push(fn.call(context, arr[i], i, this))
    }
    return newArr
  }
```

### 4. 深拷贝

**1) 浅拷贝**
1. Object.assign()
2. Array.prototype.cancat()
3. Array.prototype.slice() 

**2) 深拷贝**
1. JSON.parse(JSON.stringify())
原理: 用JSON.stringfy将对象转成JSON字符串, 再用JSON.parse()把字符串解析成对象, 一去一来, 新的对象产生了, 而且对象会开辟新的栈, 实现深拷贝.
注意: 这种方法虽然可以实现数组或对象深拷贝, 但不能处理函数.

2. 手写递归方法
递归方法实现深度克隆原理: 遍历对象, 数组直到里面都是基本数据类型, 然后再去复制, 就是深度拷贝
```javascript
  function deepClone (obj) {
    // 1. 判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝
    // 第一种方法
    // var objClone = Array.inArray(obj) ? [] : {}
    // 第二种方法
    // var objClone = obj instanceof Array ? [] : {}
    // 第三种方法
    var objClone = obj.constructor === Array ? [] : {}

    for(let k in obj) {
      if(typeof obj[k] === 'object') {
        objClone[k] = deepClone(obj[k])
      } else {
        objClone[k] = obj[k]
      }
    }
    return objClone
  }
```


3. 函数库lodash
该函数库也有提供_.cloneDeep用来做Deep Copy

### 5. textarea 设置padding好像有什么问题？这个好像我没怎么遇见


## 小米

### 1. 深克隆(可能会有数组的)
注意点：
1）、实现方案   JSON.parse + JSON.stringify  问题：无法实现对function、RegExp等特殊对象的克隆
2）、会抛弃对象的constructor,所有的构造函数会指向Object
3）、对象有循环引用,会报错

### 2. bind的实现

```javascript
  Function.prototype.myBind = function(oThis) {
    if (typeof this != 'function') {
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable')
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNop = function() {},
    fBound = function() {
      return fToBind.apply(
        this instanceof fBound ? this : oThis,
        aArgs.concat(Array.prototype.slice.call(arguments))
      )
    }

    if (this.prototype) {
      fNop.prototype = this.prototype
    }
    fBound.prototype = new fNop()
    return fBound
  }
```

### 3. ES6的 Generator async await

1) Generator函数是ES6提供的一种异步变成解决方案, 是一个状态机, 封装了多个内部状态.

执行generator函数返回的是一个遍历器对象, 也就是说, 我们可以使用next方法, 来遍历generator函数内部的每一个状态.

既然generator函数内部具有多个状态, 那么总该有一个标识来决定函数在遍历过程中应该在哪里停下来, 所以我们需要yield.

2) async 函数是什么 ? 一句话, 他就是 Generator函数的语法糖

### 4. 简单算法 两个有序子数组，合并成一个数组，如何实现，降低时间复杂度那种

```javascript
  // 方法一: 
  function concatArrs(arr1, arr2) {
    const arr = arr1.concat(arr2)
    return arr.sort((a, b) => {
      return a - b
    })
  }
  console.log(concatArrs([1, 2, 5], [1, 4, 6]))

  // 方法二: 
  function concatArrs2(arr1, arr2) {
    let index1 = 0 // 标记arr1的对比元素的初始索引值
    let index2 = 0 // 标记arr2的对比元素的初始索引值
    let newArr = [] // 作为输出的新数组

    // 当arr1 和 arr2元素均未全部存入arr中, 则从数组第一个元素开始进行比较, 将较小的元素存入newArr中
    while (index1 < arr1.length && index2 < arr2.length) {
      if (arr1[index1] <= arr2[index2]) { // 若arr1元素小于arr2元素, 则将arr1的元素存入newArr中
        newArr.push(arr1.slice(index1)[0]) // 已将元素push到输出数组中, 将数组arr1的index指向移动到下一个
        index1 ++
      } else {
        newArr.push(arr2.slice(index2)[0])
        index2 ++
      }
    }
    // 当不满足上述while条件(index1 < arr1.length && index2 < arr1.length)时, 就直接将剩余数组元素拼接输出数组newArr后面
    return newArr.concat(index1 < arr1.length ? arr1.slice(index1) : arr2.slice(index2))
  }

  console.log(concatArrs2([1, 2, 5], [1, 4, 6]))
```

### 5. es6的class会继承static的属性吗


## 搜狐
### 1. 写一个jsonp，jsonp的返回值是什么？

### 2. BFC

BFC: 块级格式化上下文, 是css布局的一个概念, 它是页面中的一块渲染区域, 有一套渲染规则, 决定了其子元素如何布局, 以及和其他元素之间的关系和作用.

通俗解释: BFC可以简单的理解为某个元素的一个CSS属性, 只不过这个属性不能被开发者显示的修改, 拥有这个属性的元素对内部元素和外部元素会表现出一些特性, 这就是BFC

触发条件或者说哪些元素会生成BFC：
满足下列条件之一就可触发BFC
　　【1】根元素，即HTML元素
　　【2】float的值不为none
　　【3】overflow的值不为visible
　　【4】display的值为inline-block、table-cell、table-caption
　　【5】position的值为absolute或fixed


BFC布局规则：
1.内部的Box会在垂直方向，一个接一个地放置。
2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
4.BFC的区域不会与float box重叠。
5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6.计算BFC的高度时，浮动元素也参与计算

BFC布局规则：
1.内部的Box会在垂直方向，一个接一个地放置。
2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠
3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
4.BFC的区域不会与float box重叠。
5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6.计算BFC的高度时，浮动元素也参与计算

BFC有哪些作用：
1. 自适应两栏布局
2. 可以阻止元素被浮动元素覆盖
3. 可以包含浮动元素——清除内部浮动
4. 分属于不同的BFC时可以阻止margin重叠

### 3. Promise实现原理, 动手实现Promise

```javascript
  class MyPromise {
    // 构造器
    constructor (executor) {
      // 初始化state为等待态
      this.state = 'pending'
      // 成功的值
      this.value = undefined
      // 失败的原因
      this.reason = undefined
      // 成功
      let resolve = (value) => {
        // state改变, resolve调用就会失败
        if (this.state === 'pending') {
          this.state = 'fulfilled'
          this.value = value
        }
      }
      // 失败
      let reject = (reson) => {
        // state改变, reject调用就会失败
        if (state === 'pending') {
          // reject调用后, state转化为失败态
          this.state = 'rejected'
          // 存储失败的原因
          this.reason = reason
        }
      }
      // 如果executor执行报错, 直接执行reject
      try {
        // 立即执行
        executor(resolve, reject)
      } catch (err) {
        reject (err)
      }
    }

    // then 方法 有两个onFulfilled onRejected
    then (onFulfilled, onRejected) {
      // 状态为fulfilled, 执行onFulfilled, 传入成功的值
      if (this.state === fulfilled) {
        onFulfilled(this.value)
      }
      // 状态为rejected, 执行onRejected, 传入失败的原因
      if (this.state === 'rejected') {
        onRejected(this.reason)
      }
    }
  }
```
### 算法: 如何将一组分成两个子集，使两组数字之和的差异最小

动态规划

## 车好多
### 1. 关于函数和函数表达式
函数声明会变量声明提升，提升到顶级作用域

### 2. 响应式布局的实现
rem
https://www.jianshu.com/p/daf1119e187b?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation

### 3. 设计组件的这种思维能力    思维能力？
 1）、先列出来我都有什么功能，每个功能点都是如何实现的
 2）、要对外暴露什么API
 3）、对内传入的参数问题

### 4. 你们是如何进行性能优化的？   
减少HTTP请求（合并js css等）减小文件的体积 压缩等  合理的使用缓存
js css 这些不经常变动的文件如何更新

### 5. Symbol  
ES5的属性名都是字符串这样很容易造成属性名冲突。保证每个属性名称都是独一无二的

## 58同城
### 1. Symbol、Map     
Symbol表示独一无二的值

### 2. webpack打包原理   webpack模块化原理

webpack中一切皆模块
webpack打包的结果是一个立即执行函数，每个模块的代码包在一个函数中作为立即执行函数的参数

  ● webpack4 提倡零配置，但是很多情况下我们还是无法做到零配置，默认了入口文件为./src/index.js 默认打包结果在 ./dist/main.js
  ● mode 参数  设置模式  development 和 production
  ● development模式  开发模式   需要配置webpack-dev-server等
  ● production模式需要配置 UglifyJSPlugin 和 sourcemaps等等
  ● 移除了CommonChunkPlugin    改为在optimazition中配置

webpack 中的tree-shaking    删除掉无用的代码，减小打包的体积
tree-shaking只能在静态modules下面工作。ES6的模块加载是静态的，因此整个依赖树可以被静态的推导出解析语法树

### 3. 算法: Top-k问题：arr  10000个数  求前k大元素

堆排序

### 4. 冒泡

```javascript
  // 冒泡排序
  function BubbleSort (arr) {
    // 外层循环: 控制趟数, 每一次找到一个最大值
    for (let i = 0; i < arr.length; i ++) {
      // 内层循环: 控制比较的次数, 并且判断两个数的大小
      for (let j = 0; j < arr.length - 1 - i; j ++) {
        // 如果前面的数大, 放到后面(当然是从小到大的冒泡排序)
        if (arr[j] > arr[j + 1]) {
          let tempItem = arr[j]
          arr[j] = arr[j + 1]
          arr[j + 1] = tempItem
        }
      }
    }
    return arr
  }
```

## 头条
### 1. vue源码知多少？vue中是如何监听数组的变化的 

重写了数组的方法，所以我们在调用push等方法来改变数组的时候可以触发视图的更新

### 2. vue 源码的模板编译了解吗


### 3. vue 源码diff 算法 是如何进行dom节点对比的  算法知多少？


### 4. 在某次事件循环中操作dom 100次  会变100次吗？   DOM是在什么时候更新的？


### 5. webpack优化相关   按需加载   单页应用如何按需加载的？


### 6. vue何时构建真是的DOM
Vue的Render函数生成虚拟dom，然后会通过dom diff，生成真实dom
这个步骤是patch方法实现的，也就是在mounted之前或者updated之前完成的

### 7. vue服务端渲染了解


### 8. vue双向绑定如何实现的


### 9. webpack 打包优化


### 10. router实现原理

## 面试题

### 1. css: flex: 1, 垂直居中属性

### 2. css兼容性处理

**1px兼容性问题**

一般设计师出图的时候，都会按照一个尺寸作为标准来出图，比如按照iPhone6的尺寸出图，就是一张750px宽的设计图，这个750px其实就是iPhone6的设备像素，在测量设计图时量到的1px其实是1设备像素，而当我们设置<meta name="viewport" content="width=device-width, initial-scale=1">时，布局视口等于理想视口等于375px，并且由于iPhone6的DPR为2，写css时的1px对应的是2设备像素，所以看起来会粗一点。
那么只要写0.5px就是对应1设备像素了嘛。是的，道理是这么说，但是很多浏览器并不支持0.5px的写法，

**解决方案: 伪类 + transform**
```javascript
// 用于容器border, 使用时覆盖border
.border-1px {
  position: relative;
  &::before {
    content: "";
    position: absolute;
    left: 0;
    top: 0;
    width: 200%;
    color: rgba(0,0,0,.04);
    height: 200%;
    -webkit-transform-origin: left top;
    transform-origin: left top;
    -webkit-transform: scale(0.5);
    transform: scale(0.5);
    pointer-events: none;
    box-sizing: border-box;
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      width: 300%;
      height: 300%;
      -webkit-transform: scale(0.33333333);
      transform: scale(0.33333333);
    }
  }
}

// 用于底边框，覆盖background
.bottom-1px {
  position: relative;
  &::after {
    content: '';
    display: block;
    width: 100%;
    text-align: right;
    height: 1px;
    background: rgba(0,0,0,0.06);
    position: absolute;
    bottom: 0;
    right: 0;
    transform: scaleY(0.5);
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      transform: scaleY(0.33);
    }
  }
}

// 用于顶边框，覆盖background
.top-1px {
  position: relative;
  &::before {
    content: '';
    display: block;
    width: 100%;
    text-align: right;
    height: 1px;
    background: rgba(0,0,0,0.06);
    position: absolute;
    top: 0;
    right: 0;
    transform: scaleY(0.5);
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      transform: scaleY(0.33);
    }
  }
}

// 用于左边框，覆盖background
.left-1px {
  position: relative;
  &::before {
    content: '';
    display: block;
    width: 1px;
    text-align: right;
    height: 100%;
    background: rgba(0,0,0,0.06);
    position: absolute;
    top: 0;
    left: 0;
    transform: scaleX(0.5);
    @media screen and (-webkit-min-device-pixel-ratio:3) {
      transform: scaleX(0.33);
    }
  }
}
```

**ios滚动卡顿, 头部有晃动**
```javascript
  -webkit-overflow-scrolling: touch;
```

**安卓部分版本input里的placeholder位置偏上**
把input的line-height设为normal
```javascript
  input{
      line-height:normal
  }
```
[参考](https://stackoverflow.com/questions/4919680/html5-placeholder-css-padding)

**ios微信浏览器弹出键盘再收起时，原虚拟键盘位点击事件无效**
```javascript
  document.body.scrollIntoView(false)
```
### 3. vuex为什么要使用action, 有什么原因, 直接使用mutation为什么不行
### 4. 普通函数, 箭头函数, 异步函数, 生产函数的区别
**箭头函数**
1. 箭头函数没有prototype(原型), 所以箭头函数本身没有this
2. this对象就是定义时所在的对象, 而不是使用时所在的对象
3. 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
4. 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
5. 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
6. this的指向是固定的, 不可变的

**异步函数**
1. callback
2. promise
3. async/await

### 5. promise为什么能链式调用, 具体原理
在then中新创建的Promise, 它的状态变为fulfilled的节点是在上一个Promise的回调执行完毕的时候. 也就是说当一个Promise的状态被fulfilled之后, 会执行其回调函数, 而回调函数返回的结果会被当做value, 返回给下一个Promise(也就是then中产生的Promise), 同时下一个Promise的状态也会被改变(执行resolve或reject), 然后再去执行其回调, 以此类推下去...链式调用的效应就出来了

### 6. promise.then(() => {return x}), x是函数, 对象, Promise有什么区别, 如果没有return呢


### 7. 异步函数并行调用方法

**Promise.all**

```javascript
  // 使用Promise.all发送请求
  // 如果中间有一个失败，则进入失败方法
  Promise.all([
      promiseUtil('http://www.baidu.com'),
      promiseUtil('http://www.g.cn'),
  ]).then((data)=>{
      // 执行成功
      console.log('请求成功:');
      //
      let [ data1, data2 ] = data;
      //
      console.log(data1, data2);
  }, (error)=>{
      console.log('请求失败：')
      console.log(error);
  })
```
### 8. 算法: 1-10000的顺序数组打乱, 并且随机删除两个数, 如何知道删除的是哪两个数(从空间耗损考虑)

1-10000相加然后 减去剩余的数 可以得到两个数的和

## 跟谁学2

### 画个三角形

```javascript
  div {
    width: 0;
    height: 0;
    border-bottom: 50px solid red;
    border-left: 50px solid transparent;
    border-right: 50px solid transparent;
  }
```

### 2. 圣杯布局, flex有哪些属性

```javascript
<body>
  <header>header</header>
  <div class="container">
    <div class="left">left</div>
    <div class="center">center</div>
    <div class="right">right</div>
  </div>
  <footer>footer</footer>
</body>
<style>
  body {
    display: flex;
    flex-direction: column;
    height: 100vh;
    min-width: 800px;
  }
  header, footer {
    background-color: antiquewhite;
  }
  .container {
    display: flex;
    flex: 1;
  }
  .left {
    /* order: -1; */
    flex: 0 0 220px;
    background: yellowgreen;
  }
  .center {
    flex: 1;
  }
  .right {
    flex: 0 0 150px;
    background: yellowgreen;
  }
</style>
```

### 3. rem适配, 为什么使用750的适配尺寸
750的尺寸是iphone6为标准的适配图

### 4. 了解es6么, 举例常用的es6方法

* 数组去重: ...new Set()
```javascript
  let arr = [1, 2, 3, 4, 3, 4]
  let arr2 = [...new Set(arr)]
  // arr2 => [1, 2, 3, 4]
```

* 合并数组: 
```javascript
  let arr1 = ['a', 'b']
  let arr2 = ['c']
  let arr3 = ['d', 'e']
  // ES5的合并: 
  arr1.concat(arr2, arr3)
  // ES6的合并
  [...arr1, ...arr2, ...arr3]
  // ['a', 'b', 'c', 'd', 'e']
```

* 字符串反转: reverse()
```javascript
  let str = '42423423424234324'
  // 原始写法: 
  str.split('').reverse().join('')
  // 展开写法
  [...str].reverse().join('')
```

* 对数组中的所有值求和: reduce
```javascript
  let arr = [1, 2, 3, 444, 5555]
  let sum = arr.reduce((x, y) => x + y)
```

### 5. 箭头函数有什么不同
* 箭头函数的 this 永远指向其上下文的  this ，任何方法都改变不了其指向, 如call(), bind(), apply(); 而普通函数的this指向调用它的那个对象
* 箭头函数不能作为构造函数, 不能使用new

### 6. 了解set, map吗
* Map: 是一组键值对的结构，查找速度快.
```javascript
  // 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：
  let m = new Map([['Tom', 95], ['Lucy', 95], ['Bob', 95]])
  m.get('Tom') // 95

  let m = new Map(); // 空Map
  m.set('Adam', 67); // 添加新的key-value
  m.set('Bob', 59);
  m.has('Adam'); // 是否存在key 'Adam': true
  m.get('Adam'); // 67
  m.delete('Adam'); // 删除key 'Adam'
  m.get('Adam'); // undefined

  // 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
  let m = new Map();
  m.set('Adam', 67);
  m.set('Adam', 88);
  m.get('Adam'); // 88
```

* Set: 无重复key的集合
```javascript
  // 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：
  let s1 = new Set() // 空Set
  let s2 = new Set([1, 2, 3]) // 含1, 2, 3

  // 重复元素在Set中自动被过滤：
  var s = new Set([1, 2, 3, 3, '3']);
  s; // Set {1, 2, 3, "3"}

  // 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：
  s.add(4);
  s; // Set {1, 2, 3, 4}
  s.add(4);
  s; // 仍然是 Set {1, 2, 3, 4}

  // 通过delete(key)方法可以删除元素：
  var s = new Set([1, 2, 3]);
  s; // Set {1, 2, 3}
  s.delete(3);
  s; // Set {1, 2}
```

### 7. 说一下尾递归
**尾调用: 函数的最后一个动作是返回一个函数的调用结果的情形**
**尾函数: 尾调用自身, 称为尾递归**

举例: 斐波那契数列

```javascript
  function fibonacci (n, prev = 0, next = 1) {
    if (n <= 1) {
      return next
    }
    return fibonacci(n - 1, next, prev + next)
  }
```


### 8. var a = [1, 3, 5], b = [2, 3, 6]; 求a和b的交集, 并集(可以使用set实现)
一般都是用loadash中封装好的方法
* 并集:
```javascript
  // 方法一: 
  [...new Set(a.concat(b))]
  // 方法二: 
  a.concat(b.filter(item => !a.includes(item)))
```

* 交集:
```javascript
  a.filter(item => b.includes(item))
```

### 9. 短除法10的二进制是多少? 用函数实现


### 10. 实现一个斐波那契函数

* 尾递归: 函数尾调用自身, 就成为尾递归
```javascript
    // 方法一: 递归(普通版)
    function fibonacci (n) {
      if (n <= 1) {
        return 1
      }
      return fibonacci(n - 1) + fibonacci(n - 2)
    }
    // console.log(fibonacci(10)) // 89
    // console.log(fibonacci(100)) // 堆栈溢出
    // console.log(fibonacci(500)) // 堆栈溢出

    // 方法二: 递归(优化版)
    function fibonacci2 (n, prev = 0, next = 1) {
      if (n <= 1) {
        return next
      }
      return fibonacci2(n - 1, next, prev + next)
    }
    console.log(fibonacci2(10)) // 89
    console.log(fibonacci2(100)) // 堆栈溢出
    console.log(fibonacci2(1000)) // 堆栈溢出
```

### 11. 正则表达式13411112345 -> 134***3333
```javascript
  '12345678901'.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2')
  // 输出: 123****8901
```

### 12. 了解node么, node是干什么的, node常用的框架
node是服务端语言

### 13. 说一下node的事件循环机制
> 当Node.js 启动, 就会初始化一个 event loop, 处理脚本时, 可能会发生异步API行为调用, 使用定时器任务或者nexTick, 处理完成后进入事件循环处理过程

每一个阶段都有一个FIFO的callbacks队列, 每个阶段都有自己的事件处理方式. 当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段.

node事件循环机制包含了六个阶段：
1. timers阶段：执行已经到期的timer回调；
2. I/O callbacks阶段：执行I/O的回调；
3. idle，prepare阶段：node内部使用；
4. poll阶段：获取新的I/O事件；
5. check阶段：执行setImmediate回调；
6. close callbacks阶段：执行close事件回调

### 15. new实际执行了哪些操作
* 得到私有属性
* 使实例对象的原型链等于构造函数的原型

```javascript
  // 声明一个函数
  var Person = function (options) {
    // 有一个私有尚需经
    this.sex = options.sex
  }
  // 公共属性prototype里加入一个方法
  Person.prototype.getSex = function () {
    return this.sex
  }
  // new Person
  var p = new Person({sex: 'man})

    // new了之后可以得到以下信息: 
  	// p 的 构造函数 是 Person 
    // 因为: 这是规则
    console.log(p.constructor === Person); // true

    
    // p 是 Person 这个构造函数的 实例对象
    // 因为: 这是规则
    console.log(p instanceof Person); // true
    
    new 做了几件事? 
    '这是new 做的第一件事', 得到私有属性
			// p 可以调用私有属性 sex
			// 说对象时候说过, 私有属性, 就是这个对象下自己有的属性, p.hasOwnProperty('属性名') === true , 就表示p下面有这个私有属性
			console.log(p.sex);
			console.log(p.hasOwnProperty('sex')); // true
			console.log(p.hasOwnProperty('getSex')); // false 表示p下面没有这个属性, 那么 p.getSex() 可以调用到么? 那就要看new做的 第二个件事了

			'这是new 做的第二件事': p.__proto__ === Person.prototype
			// p 可以调用公有方法 getSex
			// 因为 p 可以 通过原型链 找到 Person.prototype下面的方法 getSex
			console.log(p.getSex());
			console.log(p.__proto__ === Person.prototype); // true
			
			p的结构如下图, 'new 之后的结构要知道' 
			p: {
				sex: 'man',
				__proto__: {
					constructor: Person,
					getSex: function () {

					},
					__proto__: Object
				}
			}
```

### 16. vue的生命周期


### 17. vue解决过什么坑


### 18. webpack打包速度优化

## 美术宝
### 1. webpack做过什么的优化
### 2. new做了什么
### 3. 跨域方案
### 4. 如何判断对象类型
### 5. promise原理
### 6. es6用过的方法
### 7. 盒子模型
### 8. css 上下左右居中
### 9. 判断类型方式
### 10. 闭包的应用
### 11. react ref
### 12. vue改变属性的方法
### 13. webRTC?
### 14. 作用域的理解
### 15. 如何理解原型原型链
### 16. typeof null 返回什么
object

## 新氧
### 1. DOM事件三个阶段

**事件流描述的是从页面中接收事件的顺序**

DOM2级事件规定的事件流包括三个阶段:
- 事件捕获阶段: 在事件冒泡的模型中，捕获阶段不会响应任何事件;
- 处于目标阶段: 目标阶段就是指事件响应到触发事件的最底层元素上;
- 事件冒泡阶段: 冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；

### 2. js事件委托
**事件委托就是利用冒泡的原理, 把事件加到父元素或祖先元素上, 触发执行效果.**
优点: 减少内存消耗

### 3. webpack热更新原理
### 4. 前端工程化的理解

### 5. XSS, CSRF
1. XSS: 跨站脚本攻击
  (1) 原理: 页面渲染的数据包含可运行的脚本
  (2) 攻击类型: 反射型(url参数直接注入)和存储型(存储到DB后读取时注入)
  (3) 防御: 
          - 对不可信的数据源, 进行特殊字符的转义
          - 将重要的cookie标记为http only
          - 直接过滤掉javascript事件标签和一些特殊的html标签

2. CSRF: 跨站请求伪造
  (1) 原理: 在第三方网站向本网站发起请
  (2) 攻击类型: 攻击者盗用你的身份, 以你的名义发送恶意请求, 盗取账号等.
  (3) 防御: 在请求地址中添加token并验证


### 6. css 上下左右居中
```javascript
  /* 方法一: transform */  
  .wrap {
    width: 500px;
    height: 500px;
    border: 1px solid #000;
  }
  .content {
    position: relative;
    left: 50%;
    top: 50%;
    width: 200px;
    height: 200px;
    transform: translate(-50%,-50%);
    border: 1px solid blue;
  }

  /* 方法二: 绝对定位 */
  .wrap {
    position: relative;
    width: 500px;
    height: 500px;
    border: 1px solid #000;
  }
  .content {
    position: absolute;
    margin: auto;
    width: 200px;
    height: 200px;
    top:0;
    right:0;
    bottom:0;
    left:0;
    border: 1px solid blue;
  }

  /* 方法三: Flex */
  .wrap {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 500px;
    height: 500px;
    border: 1px solid #000;
  }
  .content {
    width: 200px;
    height: 200px;
    border: 1px solid blue;
  }
```

### 7. es6的for of和for in

- for of 可以直接遍历数组中的每一项

```javascript
var arr = [1, 2, 3]
for (let i in arr) {
  console.log(i) // 0, 1, 2
}
for (let i of arr) {
  console.log(i) // 1, 2, 3
}
```
### 8. es6声明变量方式和es5有什么不同
### 9. 平时做的性能优化
### 10. mvvm框架的理解

    model -> view
    view -> model
    整个过程都是响应式的, 用户只需要考虑数据就可以了, 不需要再关心视图的变化

### 11. v-model原理
### 12. es6的class
### 13. cookie session localstorage的不同
### 14. 1px解决方案
### 15. 移动端开发的时候, 如何转换px? dpr原理?

## 广联达
### 1. react原理
react是一个用户构建用户页面的js库, 相当于MVC架构中的V层框架, 与市面上的其他框架不同的是React把每个组件德昂成了一个状态,机 组件内部通过state来维护组件状态的变化, 当组件的状态发生变化时, React通过虚拟DOM技术来高效并增量更新真实的DOM 

**虚拟DOM**
React为此引入了虚拟DOM（Virtual DOM）机制，对于每个组件，React会在内存中构建一个相对应的DOM树，基于React开发时所有的DOM结构都是通过虚拟DOM进行，每当组件的状态发生变化时，React都会重新构建整个DOM数据，然后将当前的整个DOM树和上一次的DOM树进行对比，得出DOM结构变化的部分（Patchs）,然后将这些Patchs在更新到真实的DOM中。整个过程都是在内存中进行。因此是非常高效的。

### 2. react生命周期

- 挂载阶段: 
constructor(props): 实例化
componentWillMount: 用的比较少, 还未渲染DOM
render: 渲染, render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。
componentDidMount: 完成挂载, DOM节点已经生成, 在这里调用ajax请求, 返回数据setState组件会重新渲染.

- 更新阶段: 
componentWillReceiveProps(nextProps): 父组件改变后的props需要重新渲染组件时 接收一个参数nextProps,通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件
shouldComponentUpdate: 判断是否需要重绘
  1. 主要用于性能优化(部分更新)
  2. 唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新
  3. 因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断

componentWillUpdate(nextProps, nextState): shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。
componentDidUpdate(prevProps,prevState): 组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。

- 卸载阶段:
componentWillUnmount: 组件的卸载和数据的销毁, clear素有的setTimeout等, 移出所有的监听 

### 3. refs
**refs是一个获取DOM阶段或React元素实例的工具.**
使用场景:
  1. 对DOM元素焦点的控制, 内容选择或者媒体播放
  2. 通过对DOM元素控制，触发动画特效；
  3. 通第三方DOM库的集成

使用方式: 
  1. React.createRef(): 创建了一个实例属性 this.tRef, 并将其 传递给 DOM元素 div。后续对该节点的引用就可以在ref的 current属性中访问。ref的值根据节点类型的不同结果也不同
  注意: 不能在函数组件上使用ref属性, 因为他们没有实例
  2. 回调Refs

### 4. DOM树和渲染树的区别

**浏览器解析过程:**
  - DNS域名解析: 把域名解析成IP地址, 先查浏览器缓存 -> 本地的host文件 -> 本地域名解析服务器 -> 上一层域名解析服务器 直到找到.
  - TCP连接: 在http消息发送前，需要建立客户端与服务器的TCP链接，也就是进行所谓的**三次握手**。
  - 发送HTTP请求
  - 服务器处理请求并返回HTTP报文
  - 浏览器渲解析渲染过程: 当浏览器获得一个html文件时, 会“自上而下”加载，并在加载过程中进行解析渲染。
      1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
      2. 将CSS解析成 CSS Rule Tree 。
      3. 根据DOM树和CSSOM来构造 Rendering Tree。
      4. 节点信息计算(重排)，这个过程被叫做Layout(Webkit)或者Reflow(Mozilla)。即根据渲染树计算每个节点的几何信息。
      5. 渲染绘制(重绘)，这个过程被叫做(Painting 或者 Repaint)。即根据计算好的信息绘制整个页面。

### 5. 一个元素绑定两个事件, 一个捕获, 一个冒泡, 先执行哪个
### 6. react render函数是怎么执行的, ajax放到哪里执行? 为什么? 说下全过程
### 7. react遇到的坑
### 7. flux
### 8. react-router不同版本有一个什么不同?
### 9. 如果后端返回的接口的数据格式有问题? 怎么解决?
### 10. 如果react组件不能满足当前开发任务, 怎么解决?
### 11. 最近在看的新技术
### 12. 项目中的性能优化
### 13. 箭头函数和普通函数的区别
### 14. 在写高阶组件的时候需要注意什么

## 新氧二面
### 1. url都包含哪些部分
> URL即：统一资源定位符（(Uniform Resource Locator, URL）
获取方式：window.location.href

完整的URL由这几部分构成：
**scheme://host:port/path?query#fragment**

举例：http://www.maidq.com/index.html?ver=1.0&id=6#imhere

- scheme（通信协议）：常用的http、ftp、maito等
获取方式：window.location.protocol
返回：http

- host（主机）：服务器（计算机）域名系统（DNS）主机名或IP地址
获取方式：window.location.host
返回：www.maidq.com

- port（端口号）：整数，可选，省略时使用方案的默认端口，如http的默认端口为80
获取方式：window.location.port
返回：如果采用默认的80端口(update:即使添加了:80)，那么返回值并不是默认的80而是空字符
本例返回值:""

- path（路径）：由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址
获取方式：window.location.pathname
返回:/fisker/post/0703/window.location.html

- query（查询）：可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP.NET等技术制作的网页）传递参数，可有多个参数，用"&"符号隔开，每个参数的名和值用"="符号隔开。
获取方式：window.location.search
返回：?ver=1.0&id=6

- fragment（信息片段）：字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。(也称为锚点.)
获取方式：window.location.hash
返回：#imhere

### 2. h5内嵌到app, 如何调试的, jsbrige?



### 3. 如果老板反映页面访问速度太慢, 如果排期处理这个事情?
### 4. webpack自己配置过哪些? bable?
### 5. 做过的性能优化
### 6. 移动端布局原理

## 滴滴
### 1.  请实现如下布局，要求自适应各种移动端浏览器

1. vw布局方案
2. 

### 2.  有如下代码：
```javascript
    <style>
      #a {font-size:12px}
      div p{ font-size:13px }
      div .c{ font-size:14px }
      .a .b .c{ font-size:15px }
      #b .c{ font-size:16px }
    </style>
    <div id="a" class="a">
      <div id="b" class="b">
        <p id="c" class="c">I’am here</p >
      </div>
    </div>
```
请问在标准模式下显示的字符会是多大的字体？ CSS的选择器的优先级规则是怎样的？
16px 
不同级别的优先级: !important > 行内样式 > ID选择器 > 类元素器 > 元素 > 通配符 > 继承 > 浏览器默认属性

### 3.  实现一个函数 find(obj, str)，满足:
如var obj = {a:{b:{c:1}}};
find(obj,'a.b.c') //1
find(obj,'a.d.c') //undefined

```javascript
  function find(obj, str) {
    const strArr = str.split('.')
    let res = obj
    for (let i of strArr) {
      if (res[i]) {
        res = res[i]
      } else {
        return undifined
        break
      }
    }
    return res
  }
```
 

### 4. 请写出下列代码的输出结果:
```javascript
  var a=0,
  b=0;
  function A (a) {
    A = function (b) {
      console.log(a+b++);
    }
    console.log(a++);
  }
  A(1);   2
  A(2);   4 
```
### 5.   请写出匹配邮箱的正则表达式，如：
hello1988@gmail.com
hello1987@didichuxing.com.cn  

/^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/

### 6. 对于加快网页的加载速度都有哪些优化的方法？ 
1. 网络加载方面： 
- dns预加载
- 使用cdn资源
- 页面预加载
- http2.0
- 避免请求过多
- 服务端gzip(accpect-enconed)

2. 缓存
强缓存：cache-control
协商缓存：last-modify etag

3. 项目构建
压缩代码，去除注释，空白符
svg图片使用svgo压缩
js按需加载
    
### 7. 请描述一下在浏览器输入http://www.baidu.com到页面渲染，中间都经过了哪些事情。

1. DNS域名解析
2. TCP连接
3. 发送http请求
4. 服务器处理请求返回html报文
5. 浏览器渲染解析过程
6. 将html解析成DOM树
7. 将CSS解析成CSS树
8. 根据DOM树和CSS树构造成渲染树
9. 重排：节点信息计算
10. 重绘：渲染h绘制

### 8. 请说说你对web前端工程化的理解，以及如何在实际项目中运用的。

> 如何提高前端工程师的开发效率变得非常重要。这就是前端工程化所要解决的问题。前端工程化是根据业务特点，将前端开发流程规范化，标准化，它包括了开发流程，技术选型，代码规范，构建发布等，用于提升前端工程师的开发效率和代码质量。

前端工程的生命周期： 开发 <-> 测试 -> 部署

一个符合前端工程化要求的方案应该包含以下要素:
1. 开发规范：CSS规范、JS规范、图片规范、命名规范
  - 统一团队编辑器VScode配置（基于Aribnb）
  - 配置Eslint代码检测工具
2. 模块化开发
  - js的模块化：ES6 Module
  - css的模块化：例如Vue的scoped style
3. 组件化开发：组件化是在设计层面上，对UI（用户界面）的拆分。
  - Vue、React
4. 组件仓库
5. 性能优化
6. 部署
7. 开发流程
8. 开发工具
9. 监控 - 前端监控主要分为性能监控和业务监控，它应支持自由配置各种报表和一系列报警规则。
10. 构建工具：webpack4 集团builder 云构建（构建器：本质上是一个npm包，基于npm服务器上进行版本管理和安装，提供了gulp和webpack两个脚手架做参考。）
  - 本地不需要安装各种构建工具，构建成本降低
  - 多人合作时构建环境统一
  - 构建环境干净，基于Docker机制保证每次构建不受缓存影响

### 9. 已知有2个栈，有pop，push，getSize接口，请用这2个栈实现1个队列，包含dequeue和enqueue接口。

思路：入列的操作相当于入栈；出列的操作是先判断outStack的那个栈如果有值直接出，没有值的话需要将inStack(无值的话抛异常)里的值导入到outStack中，然后再出outStack

```javascript

function Queue () {
  this.inStack = []
  this.outStack = []
}
Queue.prototype.enqueue = (value) {
  this.inStack.push(value)
}
Queue.prototype.dequeue = () {
  const { inStack, outStack } = this
  if (outStack.length) {
    return outStack.pop()
  } else {
    while(inStack.length) {
      outStack.push(inStack.pop())
    }
    return return outStack.pop() || -1
  }
}

```

### 10. 设计一个异步任务类 Task
```javascript
/**
  * class Task {
        constructor() {}
        add(fn, context, …args) {}
        run() {}
        stop() {}
    }
    满足：
    function task1(next) {
        setTimeout(() => {
            console.log(1)
            next()
        }, 1000)
    }
    function task2(next, b) {
        setTimeout(() => {
            console.log(b)
            next()
        }, 1000)
    }
    let task = new Task()
    task.add(task1).add(task2, null, 3)
    task.run()
    备注：当任务函数执行 next 的时候，会跳转到下一个任务函数执行
  */
    class Task {
      constructor() {
        this.taskList = []
        this.isRun = false
      }
      add(fn, context, ...args) {
        this.taskList.push(() => {
          fn.call(context, this.next.bind(this), ...args)
        })

        return this
      }
      run() {
        this.isRun = true
        this.taskDo()

      }
      taskDo() {
        if (this.taskList.length == 0) {
          return 
        }
        this.taskList[0]()
        this.taskList.shift()
      }
      stop() {
        this.isRun = false
      }
      next() {
        if(this.isRun) {
          this.taskDo()
        }
      }
  }
```

### 11. 有一堆整数，请把它们分成三份，确保每一份的和尽量相等。

## 神策数据

### 1. Vue和React v-for或map用key是什么原因
**key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度。**

- vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中（建议先了解一下diff算法过程）。
在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key => index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。
- 就react而言，key是对于列表组件而言，并且无key或者key不唯一会报错提示

### 2. 用const定义一个数组能改变么?

> const定义引用数据类，不能修改指针指向新的对象，但可以修改它指向的数据。

### 3. 说说对作用域的理解

> 作用域(scope): 就是变量访问规则的有效范围. 就像是不同的口袋, 多数情况下这个口袋就是一个函数, 其实大括号也可以是一个作用域. 这个口袋可以调用自己的变量, 也可以调用父亲口袋里的变量, 但是不能拿别人口袋里面的东西(通过闭包的方式可以)

> 作用域链: 当查找变量的时候, 会先从当前上下文的变量查找, 如果没有找到, 就从父级(词法层面的父级)执行上下文的变量对象查找, 一直找到全局上下文的变量对象, 也就是全局对象. 由多个执行上下文的变量对象构成的链, 就是作用域链.

> 闭包: 闭包就是一个函数, 这个函数能够访问其他函数的作用域中的变量, 但是变量不进行垃圾回归, 占用内存, 所以要合理运用.

### 4. 说说对构造函数, 原型, 原型链的理解

- 构造函数: 构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。另外就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用。

- 原型: 每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性, 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。

- 原型链: 在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。
举例说明:person → Person → Object ，普通人继承人类，人类继承对象类

### 5. instanceOf, typeof, object.prototype.toString的原理

> typeof: 不同的对象在底层都表示为二进制, 在JavaScript中二进制前三位都为0的话会被判断为object类型, null的二进制表示全0, 自然前三位也是0, 所以执行typeof时会返回"object"

**注意: 最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。**
```javascript
  typeof 1 // "number"
  typeof "a" // "string"
  typeof undifined // "undifined"
  typeof function () { alert(a) } // "function"
  typeof Symbol() // "symbol"
  typeof null // "object"
  typeof [1, 2, 3] // "object"
  typeof {a: 1} // "object"
```

> instanceof: 左边是一个实例对象，右边是一个构造函数，instanceof会检查构造函数的原型对象prototype是否在左边对象的原型链上，有则返回true,否则返回false.

注意: 只适用于对象类型，不适用于简单类型的数据类型，返回boolean值.

```javascript
  // instanceof 比较内置类型

  new String('foo') instanceof String; // true
  new String('foo') instanceof Object; // true

  'foo' instanceof String; // false
  'foo' instanceof Object; // false
```

```javascript
  // 手写 instanceof
  function myInstanceOf (leftValue, rightValue) {
    let rightProto = rightValue.prototype
    leftValue = leftValue.__proto__
    while(true) {
      if (leftValue === null) {
        return false
      }
      if (leftValue === rightProto) {
        return true
      }
      leftValue = leftValue.__proto__
    }
  }
```

> object.prototype.toString(): 是Object原型对象上的方法, 返回的是代表该对象的字符串. 由于Array、String、Number、Boolean、RegExp、Date等类型都重写了toString(),如果直接调用则因为自身的原型对象上已有toString()方法,就不会调用到Object原型对象上的toString()方法了。 

```javascript
  var obj = {};
  Object.toString(obj);//"function Object() { [native code] }"
  Object.prototype.toString.call(obj);//"[object Object]"
```
举例: 
```javascript
  Object.prototype.toString.call(new Date);//[object Date]
  Object.prototype.toString.call(new String);//[object String]
  Object.prototype.toString.call(Math);//[object Math]
  Object.prototype.toString.call(undefined);//[object Undefined]
  Object.prototype.toString.call(null);//[object Null]
  Object.prototype.toString.call('') ;   // [object String]
  Object.prototype.toString.call(123) ;    // [object Number]
  Object.prototype.toString.call(true) ; // [object Boolean]
  Object.prototype.toString.call(Symbol()); //[object Symbol]
  Object.prototype.toString.call(new Function()) ; // [object Function]
  Object.prototype.toString.call(new Date()) ; // [object Date]
  Object.prototype.toString.call([]) ; // [object Array]
  Object.prototype.toString.call(new RegExp()) ; // [object RegExp]
  Object.prototype.toString.call(new Error()) ; // [object Error]
  Object.prototype.toString.call(document) ; // [object HTMLDocument]
  Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用
```

### 6. 箭头函数的this指向谁

  箭头函数的设计就是没有this, 箭头函数内部的this, 是创建该箭头函数的作用域里的this.

### 7. css上下左右居中方案(除flex布局方式)

### 8. 前端本地存储方案

**1. cookie:** 
- 不同的浏览器存放的cookie位置不一样，也是不能通用的。
- cookie的存储是以域名形式进行区分的，不同的域下存储的cookie是独立的。
- 我们可以设置cookie生效的域（当前设置cookie所在域的子域），也就是说，我们能够操作的cookie是当前域以及当前域下的所有子域
- 一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数不一样,一般为20个。
- 每个cookie存放的内容大小也是有限制的，不同的浏览器存放大小不一样，一般为4KB。
- cookie也可以设置过期的时间，默认是会话结束的时候，当时间到期自动销毁

**2. localStorage(本地存储) HTML5新方法，不过IE8及以上浏览器都兼容。**
- 生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
- 存储的信息在同一域中是共享的。
- 当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。
- 大小：据说是5M（跟浏览器厂商有关系）
- 在非IE下的浏览中可以本地打开。IE浏览器要在服务器中打开。
- localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
- localStorage受同源策略的限制

**3. sessionStorage 其实跟localStorage差不多，也是本地存储，会话本地存储**
- sessionStorage当前页面关闭的时候自动销毁

10. 防抖和节流
**1. 防抖**

> 触发高频事件后n秒函数只会执行一次, 如果n秒内高频事件再次被触发, 则重新计算时间

* 思路: 

> 每次触发事件时都取消之前的延时调用方法
输入搜索时，可以用防抖debounce等优化方式，减少http请求；
```javascript
  function debounce(fn) {
      let timeout = null; // 创建一个标记用来存放定时器的返回值
      return function () {
        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
        timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
          fn.apply(this, arguments);
        }, 500);
      };
    }
    function sayHi() {
      console.log('防抖成功');
    }

    var inp = document.getElementById('inp');
    inp.addEventListener('input', debounce(sayHi)); // 防抖
```
**2. 节流**

> 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

* 思路: 
滚动条调用接口时，可以用节流throttle等优化方式，减少http请求；
> 每次触发事件时都判断当前是否有等待执行的延时函数

```javascript
  function throttle(fn) {
      let canRun = true; // 通过闭包保存一个标记
      return function () {
        if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
        canRun = false; // 立即设置为false
        setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
          fn.apply(this, arguments);
          // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
          canRun = true;
        }, 500);
      };
    }
    function sayHi(e) {
      console.log(e.target.innerWidth, e.target.innerHeight);
    }
    window.addEventListener('resize', throttle(sayHi));
```
### 重排和重绘

**重绘不一定需要重排（比如颜色的改变），重排必然导致重绘（比如改变网页位置）

**1. 重排**
> 当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。

引发重排：
- 添加、删除可见的dom
- 元素的位置改变
- 元素的尺寸改变(外边距、内边距、边框厚度、宽高、等几何属性)
- 页面渲染初始化
- 浏览器窗口尺寸改变
- 获取某些属性。当获取一些属性时，浏览器为取得正确的值也会触发重排,它会导致队列刷新，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。

**2. 重绘**
> 是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据缘故的新属性重新绘制，使元素呈现新的外观。比如改变某个元素的背景色、文字颜色、边框颜色等等。

优化： 
- 浏览器自己的优化：浏览器会维护1个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘

减少 reflow/repaint：
- 不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的 className。
- 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。
- 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。
- 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。(table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。)
- 不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）










