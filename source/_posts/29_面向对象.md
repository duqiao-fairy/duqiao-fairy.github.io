---
title: 面向对象
---

## 一. 什么是对象
> 在ECMAScript中，对象被定义为“无序属性的集合，其属性可以包含基本值，对象或者函数”。

```javascript
  // 这里的person就是一个对象
  var person = {
    name: 'Tom',
    age: 18,
    getName: function () {}
    parent: {}
  }
```
也就是说，在JavaScript中，对象无非就是由一些列无序的key-value对组成。其中value可以是基本值，对象或者函数。

## 二. 工厂模式
就以person对象为例。假如我们在实际开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，虽然他们有很多相似之处，但是我们不得不重复写两次。
很显然这并不是合理的方式，当相似对象太多时，大家都会崩溃掉。
我们可以使用工厂模式的方式解决这个问题。顾名思义，工厂模式就是我们提供一个模子，然后通过这个模子复制出我们需要的对象。我们需要多少个，就复制多少个

普通模式：
```javascript
  var perTom = {
    name: 'TOM',
    age: 20,
    getName: function () {
      return this.name
    }
  }

  var perJack = {
    name: 'Jack',
    age: 22,
    getName: function () {
      return this.name
    }
  }
```

工厂模式：
```javascript
  var createPerson = function () {
    // 声明一个中间对象，该对象就是工厂模式的模子
    var o = new Object()

    // 依次添加我们需要的属性和方法
    o.name = name
    o.age = age
    o.getName = function () {
      return this.name
    }
    return o
  }

  // 创建两个实例
  var PerTom = createPerson('Tom', 20)
  var PerJack = createPerson('Jack', 22)
```
相信上面的代码并不难理解，也不用把工厂模式看得太过高大上。很显然，工厂模式帮助我们解决了重复代码上的麻烦，让我们可以写很少的代码，就能够创建很多个person对象。但是这里还有两个麻烦，需要我们注意。
第一个麻烦就是这样处理，我们没有办法识别对象实例的类型。无法使用instanceof识别对象的类型
第二: 对象下每个属性都是重新创建的, 开辟一个新的地址, 没有办法共享
因此在工厂模式的基础上，我们需要使用构造函数的方式来解决这个麻烦。

## 三. 构造函数

构造函数：
```javascript
  var Person = function (name, age) {
    this.name = name
    this.age = age
    this.getName = function () {
      return this.name
    }
  }

  var p1 = new Person('Tom', 20)
  console.log(p1.getName()) // Tom

  console.log(p1 instanceof Person) // true
```
与普通函数相比，构造函数并没有任何特别的地方，首字母大写只是我们约定的小规定，用于区分普通函数； 

**new**关键字让构造函数具有了与普通函数不同的许多特点，而new的过程中，执行了如下过程：
1. 创建了一个新的空对象；var obj = {}
2. 将该对象的原型链指向构造函数的原型；即obj.__proto__ = 构造函数.prototype
3. 将构造函数的this，指向新对象，执行构造函数的代码，向新对象中添加属性和方法；构造函数.call(obj);
4. 返回新对象地址即实例对象

## 四. 原型和原型链

- 原型: 每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性, 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。

- 原型链: 在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。

举例说明:person → Person → Object ，普通人继承人类，人类继承对象类

构造函数的原型等于该实例对象的原型链，这是js这门语言的机制, 正是因为有这样的特性, 面向对象的功能才能展现的更丰富, 比如继承。

## 五. 继承
> 自身有父类的一些特征，自己也有自己的特征

### es3年代的继承

#### 1. 拷贝继承

实现思路：
  1）属性的继承：调用父类并且使用call或apply来修改this指向
  2）方法的继承：将父类的原型上的方法通过for in赋值给子类

具体代码：
```javascript
  function Person (options) {
    this.sex = options && options.sex
  }

  Person.prototype.getSex = function () {
    return this.sex
  }

  function GoodPerson (options) {
    // 继承第一步：继承私有属性和方法
    Person.call(this, options)
    // 添加私有属性
    this.job = options.job
  }
  // 继承第二步：继承公共属性和方法
  extend(GoodPerson.prototype, Person.prototype)
  GoodPerson.prototype.getJob = function () {
    return this.job
  }

  function extend (obj1, obj2) {
    for (var key in obj2) {
      obj1[key] = obj2[key]
    }
  }

  var gp = new GoodPerson({
      sex: 'man',
      job: 'fontEnd'
    })

  console.log(gp.job) // fontEnd
  console.log(gp.sex) // man
  console.log(gp.getJob()) // fontEnd
  console.log(gp.getSex()) // man
  // p.hasOwnProperty('属性名') === true , 就表示p下面有这个私有属性
  // gp 可以调用私有属性 sex
  console.log(gp.hasOwnProperty('sex')) // true 
  // getSex 是公共方法getSex gp 可以 通过原型链 找到 Person.prototype下面的getSex
  console.log(gp.hasOwnProperty('getSex')) // false

```

#### 2. 一句话实现继承

实现思路：GoodPerson.prototype = new Person()

具体代码：
```javascript
    function Person (options) {
      this.sex = options && options.sex
    }

    Person.prototype.getSex = function () {
      // console.log(this) // Person(){...}
      // console.log(this.sex) // man
      return this.sex
    }

    function GoodPerson (options) {
      Person.call(this, options)
      this.job = options.job
    }

    // 一句话来喽
    GoodPerson.prototype = new Person()

    GoodPerson.prototype.getJob = function () {
      return this.job
    }

    // 可以尝试了
    var gp = new GoodPerson({
      sex: 'man',
      job: 'frontEnd'
    })

    // gp 既能搞到他下面的属性 job, getJob 也能拿到父类 Person 的 sex 和 getSex
    console.log(gp.job)
    console.log(gp.sex)
    console.log(gp.getJob())
    console.log(gp.getSex())
```

缺点：sex 这个私有属性出现了两份，gp.sex 是因为Person.call(this, options)

gp.__proto__.sex 为什么会有这个属性呢? 
是因为 GoodPerson.prototype = new Person();
			即: GoodPerson.prototype 就会有sex这个属性
			这个sex本来是私有的, 放到 GoodPerson.prototype 变成公有属性了

#### 3. 类式继承

实现思路：
  1）属性的继承：调用父类并且使用call或apply来修改this指向
  2）方法的继承：
    i. 创建一个空函数，空函数里面没有私有属性
    ii. 我们只在空函数的prototype上做处理, 空函数的prototype 指向Person.prototype的地址.
    iii. 通过new F(); 得到 F.prototype 下面公有的属性,即得到Person.prototype 的公有属性, 而且还没有受到Person 这个函数里面 sex这个私有属性的影响。

具体代码：
```javascript
  function Person (options) {
    this.sex = options && options.sex
  }
  Person.prototype.getSex = function () {
    return this.sex
  }

  function GoodPerson (options) {
    Person.call(this, options)
    this.job = options.job
  }
  // 第一步：创建一个空函数，空函数里面没有私有属性
  var Func = function () {}
  // 第二步：我们只在空函数的prototype上做处理, 空函数的prototype 指向Person.prototype的地址
  Func.prototype = Person.prototype
  // 第三步：首先: 通过new Func(); 得到 F.prototype 下面公有的属性, 即得到Person.prototype 的公有属性, 而且还没有受到Person 这个函数里面 sex这个私有属性的影响
  GoodPerson.prototype = new Func()

  // 第四步：继续扩展GoodPerson.prototype 下面的属性
  GoodPerson.prototype.getJob = function () {
    return this.job
  }
```

#### 4. 静态方法的继承

```javascript
  // 比如Person下面有个 trim 方法
  // trim就是Person的静态方法
  Person.trim = function (str) {
    return str.replace(/(^\s*)|($\s*)/g, '')
  }

  // 静态方法的继承：GoodPerson.super.trim就可以调用了
  GoodPerson.super = Person
```

#### 5. 封装一个继承函数

实现要点：
  （1）利用 Person.call(this) 执行“方法借用”，获取 Person 的属性
  （2）利用一个空函数将 Person.prototype 加入原型链

```javascript
    /**
    * @param {function} superClass：父类
    * @param {function} subClass：子类
    * @return {function} 子类
    */
    function inherit (superClass, subClass) {
      if (typeof subClass !== 'function' || typeof superClass !== 'function' ) {
        return subClass
      }

      // 1. 继承prototype共有属性
      var Func = function () {}
      Func.prototype = superClass.prototype
      subClass.prototype = new Func()

      // 2. 更改constructor指向
      subClass.prototype.constructor = subClass
      Func = null

      // 3. 继承静态方法
      subClass.superClass = superClass

      return subClass
    }

    // 父类
    function Person (options) {
      this.sex = options && options.sex
    }
    Person.prototype.getSex = function () {
      return this.sex
    }
    // 子类
    function GoodPerson (options) {
      // this.constructor === GoodPerson
		  // GoodPerson.superClass.apply(this, arguments)
      this.constructor.superClass.apply(this, arguments)
      this.job = options.job
    }

    // 继承
    inherit(Person, GoodPerson)
    
    GoodPerson.prototype.getJob = function () {
		  return this.job
	  }

    var gp = new GoodPerson ({
      sex: 'man',
      job: 'web'
    })
```

### es5年代的继承

实现要点：
  （1）利用 Person.call(this) 执行“方法借用”，获取 Person 的属性
  （2）利用 ES5 增加的 Object.create 方法将 Person.prototype 加入原型链

**Object.create()的实现原理是底层利用了new方法，实现了这个原型链的返回值。**

```javascript
  // 实际就是返回一个新对象, 然后 __proto__ === proto
  Object.create = function(proto) {
    functon F() {}
    F.prototype = proto
    return new F()
  }
```

继承的代码实现：GoodPerson.prototype = Object.create(Person.prototype)

```javascript
  function Person (options) {
    this.sex = options && options.sex
  }
  Person.prototype.getSex = function () {
    return this.sex
  }

  function GoodPerson (options) {
    Person.call(this, options)
    this.job = options.job
  }
  // 利用 ES5 增加的 Object.create 方法继承共有属性
  GoodPerson.prototype = Object.create(Person.prototype)
  
  GoodPerson.prototype.getJob = function () {
    return this.job
  }
```


### es6年代的继承

#### 通过class的方式实现继承

> class仅仅为一个语法糖，是在原先构造函数的基础上出现的class，所以使用构造函数构造类，或者使用class语法糖构造类都是相同的。具体还是使用prototype和this来进行模拟类。

```javascript
  // 父类
  class Person {
    constructor(options) {
      this.sex = options.sex
    }
    getSex () {
      return this.sex
    }
  }
  // 子类
  class GoodPerson {
    constructor(options) {
      super(options)
      this.job = options.job
    }
    getJob () {
      return this.job
    }
  }
  var p = new Person ({
    sex: 'woman'
  })

  var gp = new GoodPerson ({
    sex: 'man',
    job: 'web'
  })
```

**注意: 如果要使用父类的属性那么一定要带super，不带就报错**

```javascript
class 子类 extends 父类{
  constructor(options){
    *** this.name = options.name //报错
    super(options)
    // 添加的属性一定要放在super下面
    this.age = options.age //不报错
  }
}

```

#### static

> 是一个静态方法，该方法new出来的实例对象不能进行使用。常常用于工具函数的书写。

```javascript
  class Person {
    constructor(options) {
      this.sex = options.sex
    }
    getSex () {
      return this.sex
    }
    // 静态方法
    static printSex (obj) {
      console.log('我的性别是:', obj.sex)
    }
  }

  class GoodPerson extends Person {
    constructor(options) {
      super(options)
      this.job = options.job
    }
    getJob () {
      return this.job
    }
  }

  var p = new Person ({
    sex: 'woman'
  })

  var gp = new GoodPerson ({
    sex: 'man',
    job: 'web'
  })

  Person.printSex(p) // 我的性别是: woman
  Person.printSex(gp) // 我的性别是: man
```

  


