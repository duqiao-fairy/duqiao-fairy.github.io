---
title: 数据结构设计
---

## 题目: 使用JS代码实现一个事件类Event, 包含下面功能: 绑定事件, 解绑事件和派发事件.

在稍微复杂点的页面中, 比如组件化开发的页面, 同一个页面由两三个人来开发, 为了保证组件的独立性和降低组件间的耦合度, 我们往往使用[订阅发布模式], 即组件间通信使用事件监听和派发的方式, 而不是直接相互调用的组件方法, 这就是题目还要求写的Event类.

这个题目的核心是一个事件类型对应回调函数的数据设计. 为了实现绑定事件, 我们需要一个_cache对象来记录绑定了哪些事件. 而事件发生的时候, 我们需要从_cache中读取出来事件回调, 依次执行它们. 一般页面中事件派发(读)要比事件绑定(写)多. 所以我们设计的数据结构应该尽量的能够在事件发生时, 更加快速的找到对应的回调函数们, 然后执行.

**代码实现:**
```javascript
  class Event {
    constructor() {
      // 存储事件的数据结构
      // 为了查找迅速, 使用了对象(字典)
      this._cache = {}   
    }

    // 绑定
    on(type, callback) {
      // 为了按类查找方便和节省空间, 将同一类型事件放到一个数组中
      // 这里的数组是队列, 遵循先进先出
      // 即先绑定的事件先出发
      let fns = (this._cache[type] = this._cache[type] || [])
      if (fns.indexOf(callback) === -1) {
        fns.push(callback)
      }
      return this
    }

    // 触发
    trigger(type, data) {
      let fns = this._cache[type]
      if(Array.isArray(fns)) {
        fns.forEach((fn) => {
          fn(data)
        })
      }
      return this
    }

    // 解绑
    off(type, callback) {
      let fns = this._cache[type]
      if(Array.isArray(fns)) {
        if (callback) {
          let index = fns.indexOf(callback)
          if (index !== -1) {
            fns.splice(index, 1)
          }
        } else {
          // 全部清空
          fns.length = 0
        }
      }
      return this
    }
  }

  // 测试用例
  const event = new Event()
  event.on('test', (a) => {
    console.log(a)
  })
  event.trigger('test', 'hello world')

  event.off('test')
  event.trigger('test', 'hello world')



```
